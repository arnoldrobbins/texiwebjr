\input mftmac % for Metafont logo
\input texinfo   @c -*-texinfo-*-
@c vim: filetype=texinfo tabstop=4 shiftwidth=4
@c %**start of header (This is for running Texinfo on a region.)
@setfilename texiwebjr.info
@settitle TexiWeb Jr.---A Super Simple Literate Programming System
@c %**end of header (This is for running Texinfo on a region.)

@c Change how xref titles are quoted.
@dquotexrefs
@set FORPRINT 1
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear


@c The following information should be updated here only!
@c This sets the edition of the document.

@c These apply across the board.
@set UPDATE-MONTH April, 2019
@set EDITION 1.2

@set TITLE Literate Programming Made Easy
@set SUBTITLE TexiWeb Jr.@:---A Super Simple Literate Programming System
@set SHORTTITLE TexiWeb Jr.@:

@ifweave
@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook
@end ifweave

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@ifnottex
@macro MF{}
@sc{METAFONT}
@end macro
@end ifnottex

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c @finalout
@end iftex
@c @cropmarks

@copying
@docbook
<para>Published by:</para>

<literallayout class="normal">Arnold David Robbins
P.O. Box 354
Nof Ayalon
D.N. Shimshon 9978500
ISRAEL
Email: <email>arnold@@skeeve.com</email>
URL: <ulink url="http://www.skeeve.com/">http://www.skeeve.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; 2013, 2014, 2015, 2016, 2018, 2019
Arnold David Robbins
All Rights Reserved.</literallayout>
@end docbook

@ifnotdocbook
Copyright @copyright{} 2013, 2014, 2015, 2016, 2018, 2019 @*
Arnold David Robbins @*
All Rights Reserved.
@end ifnotdocbook
@sp 1
The @command{jrtangle} and @command{jrweave} programs are copyright
@copyright{} 2013, 2014, 2015, 2016, 2018, 2019 by Arnold David Robbins.
They are published under the conditions of the GNU General Public License,
version 3.
@sp 1
The @file{texiwebjr.twjr} literate source code file for
@command{jrtangle} and @command{jrweave} is
@copyright{} 2013, 2014, 2015, 2016, 2018, 2019 by Arnold David Robbins.
Starting at Edition 0.95 and forward,
it is published under the conditions of the GNU General Public License,
version 3.
@sp 2
This is Edition @value{EDITION} of
@cite{@value{TITLE}}: @cite{@value{SUBTITLE}}.
It was last updated in @value{UPDATE-MONTH}.
@end copying

@c The name of our program. Setting it as a macro makes it
@c easier to change later.
@set TWJR @sc{TexiWeb Jr.@:}

@c @smallbook

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@setchapternewpage odd

@c Uncomment this if it's ever printed as a real book(let).
@shorttitlepage @value{TITLE}

@titlepage
@title @value{TITLE}
@subtitle @value{SUBTITLE}
@subtitle Edition @value{EDITION}
@subtitle Last updated: @value{UPDATE-MONTH}
@author Arnold D. Robbins

@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
Arnold David Robbins @*
P.O. Box 354 @*
Nof Ayalon @*
D.N. Shimshon 9978500 @*
ISRAEL @*
Email: @EMAIL{arnold@@skeeve.com,arnold AT skeeve.com} @*
URL: @url{http://www.skeeve.com/} @*

@insertcopying
@end ifnotdocbook
@end titlepage

@set DRAFT @i{DRAFT}

@iftex
@headings off
@evenheading @thispage @| @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @| @thispage
@end iftex

@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top General Introduction
@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This file documents @value{TWJR}, a program suite for Literate Programming
on top of the Texinfo document formatting markup language.

@insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@menu
* Preface::                        Preface.
* Introduction::                   Introduction.
* Example C Program::             
* jrtangle code::                  The code for @command{jrtangle}.
* jrweave code::                   The code for @command{jrweave}.
* Bootstrapping::                  Chicken and egg issues.
* Evaluation and Futures::         Evaluation and future work.
* Command summary::                Alphabetic list of @value{TWJR} commands.
* File Chunk Summaries::           Alphabetic lists of file chunks by
                                   definition.
* Use of @command{gawk} features:: Features Specific to @command{gawk}.
* Bibliography::                   Reference material.
* Concept Index::                  The concept index.

@detailmenu
* Lit prog and me::                Literate programming and me.
* Audience::                       Who should read this @value{DOCUMENT}.
* Overview::                       An overview of the @value{DOCUMENT}.
* Conventions::                    Typographical conventions.
* Acknowledgements::               Acknowledgements.
* Litprog intro::                  Quick intro to Literate Programming.
* Processing a document::          Creating code and documentation.
* Why texinfo::                    Why build on top of Texinfo.
* Why awk::                        Why implement in @command{awk}.
* jrtangle header::                Getting Started.
* jrtangle ifweave iftangle::      Text inclusion/exclusion for
                                   @command{jrtangle}.
* jrtangle texinfo vars::          Using Texinfo variables in code.
* jrtangle handle ignore::         Handling @code{@@ignore} lines.
* jrtangle file chunks::           Processing file chunks for
                                   @command{jrtangle}.
* jrtangle start chunk collection:: Starting chunk collection.
* jrtangle finish chunk collection:: Finishing file and code chunk collection.
* jrtangle collecting chunk lines:: Collecting chunk lines.
* jrtangle finish file chunk::     Completing file collection for
                                   @command{jrtangle}.
* jrtangle code chunks::           Processing code chunks for
                                   @command{jrtangle}.
* jrtangle error checking::        Checking for errors in @command{jrtangle}.
* Expanding code chunks::          Expanding code chunks into straight code.
* jrtangle expanding values::     
* jrtangle before everything::     Doing something before extracting any
                                   files.
* jrtangle avoiding update::       Leaving unmodified files alone.
* jrtangle shell debug::           Debugging shell commands run by
                                   @command{jrtangle}.
* jrtangle after creation::        Doing something after creating a file.
* Common Chunks::                  Common code chunks and functions.
* jrweave two passes::             Two pass design.
* jrweave initial code::           Initial Stuff and Printing A Warning.
* jrweave handle ignore::          Handling @code{@@ignore} lines.
* jrweave ifweave iftangle::       Text inclusion/exclusion for
                                   @command{jrweave}.
* jrweave delete jrtangle code::   Removing stuff for @command{jrtangle}.
* jrweave choosing code size::     Choosing the code size.
* jrweave language additions::     Extra stuff for authors.
* jrweave additional macros::      Macros for writing documents.
* jrweave turning on xref titles:: Turning on titles in xrefs.
* jrweave sidebars::               Providing sidebars.
* jrweave @TeX{} control::         Additional features for @TeX{}.
* Cross-reference quoting::        Changing quoting for cross-references.
* PDF links::                      Changing the color of internal PDF links.
* URL formatting::                 Link color and text formatting for URLs.
* Improved index entries::         Creating improved index entries.
* jrweave chunk indexes::          Create indices for chunk definition and
                                   references.
* jrweave def/use collecting::     Collecting definition and use information.
* jrweave file chunks::            Processing file chunks.
* jrweave chunk collection::       Collecting file and code chunks.
* jrweave file chunks processing:: Processing the file chunks.
* jrweave file chunks printing::   Printing the file chunks.
* Keeping lines together::         Keeping chunk lines together.
* Formatting the anchor::          Formatting the anchor.
* Expanding tabs::                 Expanding tabs.
* Printing the complete chunk::    Printing the complete chunk.
* Printing chunk cross references:: Printing chunk cross references.
* jrweave code chunks::            Processing code chunks.
* jrweave file defs::              Printing file definitions.
* jrweave code defs and refs::     Printing code definitions and references.
* jrweave print code defs::        Printing code definitions.
* jrweave print code refs::        Printing code references.
* jrweave print setup recipe::     Printing the initial setup recipe.
* jrweave last bit::               Passing everything else through.
* jrweave expanding tabs::         Expanding tabs.
* jrweave helper functions::       Helper functions for @command{jrweave}.
* Initial bootstrapping::          Bringing up the system from scratch.
* The initial setup::              The initial setup.
* The Makefile::                   Keeping the system going.
* Downloading from git::           Downloading from the Git repository.
@end detailmenu
@end menu

@summarycontents
@contents

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword

@node Preface
@unnumbered Preface

Literate programming is a programming style created originally by
Professor Donald E.@: Knuth, of Stanford University.
Programming well this way requires the author of a program to
present clear explanations of both how his program functions
and why it is written in the way it is. The discipline involved
leads to better programs.

The Texinfo markup language is the official documentation markup
language of the GNU Project. It makes writing program documentation
pleasant. In addition, these documents can be converted to multiple
formats for end use. The most important formats (in my
opinion) are HTML for viewing with a Web browser, @TeX{} for printing,
and DocBook for publishing.

This @value{DOCUMENT} describes @value{TWJR}, a system that provides
literate programming on top of the Texinfo markup language.

The canonical source for @value{TWJR} is
@url{http://github.com/arnoldrobbins/texiwebjr}.

@menu
* Lit prog and me::             Literate programming and me.
* Audience::                    Who should read this @value{DOCUMENT}.
* Overview::                    An overview of the @value{DOCUMENT}.
* Conventions::                 Typographical conventions.
* Acknowledgements::            Acknowledgements.
@end menu

@node Lit prog and me
@unnumberedsec Literate Programming and Me

I probably first encountered literate programming in Jon Bentley's
@cite{Programming Pearls} columns in CACM in the mid-1980s. Sometime
later I found and read Knuth's book on the subject (@pxref{Bibliography}).

I do know that I was dabbling with it as early as sometime in the first
half of 1998, since that is when I found and fixed a race condition in
@command{noweb}'s @command{troff} backend.

@cindex Brennan, Michael
From October of 1999 through September of 2001, I did some consulting work
for Mike Brennan, the author of
@uref{http://www.invisible-island.net/mawk, @command{mawk}}
and a good friend.  We used
Mike's @command{mweb} system@footnote{As I recall it, sometime earlier I
had pointed him at literate programming. He created his @command{mweb} in
1996.} for the work. @command{mweb} used @command{notangle} for tangling.
For weaving, it used
@command{markup} from @command{noweb} with a backend written
(of course) in @command{mawk}, and a custom set of @TeX{} macros.
This was certainly the largest body of literate code I have written
to date.  (At this point, I don't recall the details of @command{mweb},
but undoubtedly it was an influence for @value{TWJR}) @c no period!

In April of 2003, I used @command{noweb} to rewrite the input record
handling of @command{gawk}, considerably simplifying it in the process. To
this day, there have been very few bugs in it, and it certainly qualifies
as ``golden code.''

Alas, though. I've done very little literate programming since, until now.
I hope that this will be the start of a new phase for me, where I can write
code that will be appealing to read and enjoyable to write.

@node Audience
@unnumberedsec Intended Audience

@quotation
When all you have is a hammer, everything looks like a nail.
@author Anonymous
@end quotation

You should read this @value{DOCUMENT} if you are interested in
literate programming, and in seeing how one programmer decided to
create his own literate programming system for use in writing
large programs.

You may also find this @value{DOCUMENT} interesting if you like
programming using scripting languages, as the code is written in
@command{awk}, the author's favorite hammer.

@ifnotdocbook
@c Scale figure to 4.5 inches which is good for both smallbook
@c and regular.  TeX will scale height also automatically.
@float Figure,third-way
@caption{Third Way (@url{http://xkcd.com/1285})}
@center @image{third_way, 5in, , Third Way}
@end float
@end ifnotdocbook

@docbook
<figure id="figure-third-way" float="0">
<title>Third Way (<ulink url="http://xkcd.com/1285">http://xkcd.com/1285</ulink>)</title>
<mediaobject>
<imageobject role="web"><imagedata fileref="third_way.png" format="PNG"/></imageobject>
</mediaobject>
</figure>
@end docbook

Many people today are used to using WYSIWYG document creation programs.
Texinfo uses the older, batch-formatting model of document creation, where
you @dfn{mark up} the text with formatting instructions, and the input
does not physically resemble the output.
@ifnotdocbook
(@xref{third-way}.)
@end ifnotdocbook
@ifdocbook
@inlineraw{docbook, (<xref linkend="figure-third-way"/>.)}
@end ifdocbook
Such systems
may take longer to learn, but ultimately they provide more control over
your document, and you spend your time thinking about your content instead
of fighting the document creation program's ideas of how to do things.
Thus, you should be familiar with the Texinfo markup language.

You should also be familiar with the @command{awk} programming language.
In particular, @value{TWJR} makes use of additional features in
@command{gawk} (the GNU implementation of Awk).@footnote{This
in hardly surprising, since I maintain @command{gawk}.}

You should also understand at least the basics of @command{make}
and @file{Makefile} construction, since it is important that
@value{TWJR} work in a Unix-style command-line environment
with @command{make}.

@node Overview
@unnumberedsec What Is Covered

This @value{DOCUMENT} provides the full source and description
of the @value{TWJR} literate programming system.
The @value{CHAPTER}s and what they cover are as follows.

@c No period when TWJR ends a sentence, since it has a period in it.
@ref{Introduction}, briefly introduces literate programming
and describes some of the motivation for @value{TWJR}

@ref{jrtangle code}, presents the code for @command{jrtangle}, the
``tangling'' component of @value{TWJR}

@ref{jrweave code}, presents the code for @command{jrweave}, the
``weaving'' component of @value{TWJR}

@ref{Bootstrapping}, describes the issues involved in bringing up a
literate programming system from scratch and shows the initial setup
recipe. It also presents the @file{Makefile} used for ongoing maintenance,
and for lack of a better place, describes how to obtain the source for
the system using Git.

@ref{Evaluation and Futures}, provides some brief discussion
of various design decisions, as well as looking at possible
future features to add.

@ref{Command summary}, presents an alphabetic list of all
the @value{TWJR} commands. It also lists the variables that
a user may set using @command{gawk}'s @option{-v} option to
affect the behavior of the programs.

@ref{File Chunk Summaries}, provides
alphabetic lists of source files by definition.

@ref{Use of @command{gawk} features}, looks at the
@command{gawk}-specific features that are used with a brief
description of what to use instead if you wish to use a
standard version of @command{awk} instead of @command{gawk}.@footnote{Although
why anyone would want to do so is beyond me.}

@ref{Bibliography}, lists books that may be of interest.

At least one index follows the bibliography.

@node Conventions
@unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example 

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  File names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

Finally, I sometimes break with tradition, and write in the first
person, instead of using ``the royal we.''  However, use of ``we''
is appropriate during conversational-style prose; I would like you, the reader,
to feel as if you're engaging in a conversation with me, the author.
To that end, ``we'' is entirely correct.

@node Acknowledgements
@unnumberedsec Acknowledgements

I would like to acknowledge the following people.

@itemize @bullet
@item
@cindex Kernighan, Brian W.@:
@cindex Aho, Alfred V.@:
@cindex Weinberger, Peter J.@:
Alfred V.@: Aho, Peter J.@: Weinberger, and Brian W.@: Kernighan,
for inventing the @command{awk} language.

@item
@cindex Stallman, Richard M.@:
Richard M.@: Stallman for inventing the Texinfo markup language.

@item
Donald E.@: Knuth for inventing literate programming.

@item
Norman Ramsey for inventing @command{noweb}.

@item
Ben Pfaff for inventing the original TexiWeb.

@item
@cindex Berry, Karl
Karl Berry for his infinite patience with my questions about
and suggestions for Texinfo.

@item
@cindex Brennan, Michael
Mike Brennan for his feedback on earlier versions
of @value{TWJR}.  They helped to significantly improve it.
@end itemize

@node Introduction
@chapter Introduction

This @value{DOCUMENT} documents @value{TWJR}, an intentionally
simple literate programming system.

This @value{CHAPTER} introduces the basic concepts behind literate
programming, and describes how to use these tools to create literate
programs.  It also discusses why @value{TWJR} is built on top Texinfo
and implemented in @command{awk}.

@menu
* Litprog intro::               Quick intro to Literate Programming.
* Processing a document::       Creating code and documentation.
* Why texinfo::                 Why build on top of Texinfo.
* Why awk::                     Why implement in @command{awk}.
@end menu

@node Litprog intro
@section What Is Literate Programming?

@cindex McPhee, Patrick TJ
@quotation
Without wanting to be elitist, the thing that will prevent literate
programming from becoming a mainstream method is that it requires thought
and discipline. The mainstream is established by people who want fast
results while using roughly the same methods that everyone else seems
to be using, and literate programming is never going to have that kind
of appeal. This doesn't take away from its usefulness as an approach.
@author Patrick TJ McPhee
@end quotation

@cindex Knuth, Donald E.@:
@dfn{Literate programming} is a programming style invented by
@uref{http://www-cs-faculty.stanford.edu/~knuth/, Professor Donald E.@: Knuth}
of Stanford University for implementing the
@uref{http://www.tug.org, @TeX{} document formatter}
and @MF{} font-creation programs.

A literate program is a mixture of program fragments that do some
particular task, and explanatory prose describing what the code is
doing. Preferably, the prose also describes @emph{why} the code is
implemented in a particular fashion.

The significant difference over simply using lots of comments is
that the code is presented in the order that makes the most sense for
the human reading and understanding the program, as opposed to the
order needed for the programming language's compiler or interpreter.
More information and pedagogy may be found on
@uref{http://www.literateprogramming.com, the literate programming website}.
Please see there.

Knuth's original @command{WEB} system was built on top of and for use
with Pascal.  When this was done in the early 1980s, Pascal was just about
the only language that was popular, generally portable, and basically
usable for large programs (despite a number of constraints). @command{WEB}
provided a number of facilities to make Pascal programming easier, and
also ``pretty printed'' the code in the finished document.  (Today Knuth
uses @uref{http://www-cs-faculty.stanford.edu/~knuth/cweb.html,
@command{CWEB}}, which is similar to the original @command{WEB}
but is intended for use with C.)

@cindex Ramsey, Norman
@cindex Pfaff, Ben
Many literate programming tools have been developed since then.
@value{TWJR} is inspired by two in particular:
@uref{http://www.cs.tufts.edu/~nr/noweb/, Norman Ramsey's @command{noweb}},
and
@uref{http://searchcode.com/codesearch/view/14097352, Ben Pfaff's TexiWeb}.

@cindex @command{noweb} literate programming tool
@command{noweb} makes a conscious attempt to provide minimal additional
markup over and above the document formatting language. It also attempts
to be portable to any markup language, not just @TeX{} or @LaTeX{},
and to any programming language.  Finally, it is programmable, with
several stages in a pipeline and a documented intermediate format,
making it easily extensible.  It is the ``minimal additional markup''
aspect of @command{noweb} that I find particularly appealing.

@cindex TexiWeb literate programming tool
TexiWeb was created by Ben Pfaff for writing his
@uref{http://adtinfo.org/, AVL library}.
It builds on the Texinfo markup language, which at first glance is
exactly what I was looking for: Texinfo + Literate Programming.
However, TexiWeb has two drawbacks: it is poorly documented,
and it assumes that the code is written in C, and thus does
pretty-printing.

I wanted to be able to use Texinfo, and to write code in any language.
Thus, @value{TWJR}, which acknowledges TexiWeb as its inspiration,
and the Texinfo bias, but which is built from scratch.

@node Processing a document
@section Processing A Document

Traditionally, a web document is processed in two different ways,
towards two different ends.

@table @dfn
@item Tangling
This process turns a literate program into straight code that can be
either run directly (scripting languages), or compiled (C, C++, etc.).
Knuth's @command{WEB} provided @command{TANGLE}, which created a straight
Pascal program.  The @command{noweb} suite has @command{notangle}.

The @value{TWJR} tangling program is called @command{jrtangle}.  It reads
a @value{TWJR} document and produces the source files defined therein for
running or compiling.

@item Weaving
This process turns a literate program into a form that can be processed
for printing.  Knuth's @command{WEB} provided @command{WEAVE}, which
created a straight @TeX{} document.  The @command{noweb} suite has
@command{noweave}.

The @value{TWJR} weaving program is called @command{jrweave}.  It reads
a @value{TWJR} document and produces a Texinfo document which can then
be processed by @command{texi2dvi} or @command{texi2pdf} to produce
a printable file. (It can also be processed with @command{makeinfo}
to produce Info, HTML, DocBook, or Texinfo XML.)

@end table

By convention, @value{TWJR} files have a @file{.twjr} extension.
This is valuable, since the @TeX{} by-product files generally have
two- or three-character extensions. Thus, for a document @file{foo.twjr},
you can safely say @samp{rm foo.?? foo.???} (in a Bourne-compatible
shell) to remove the by-product files without accidentally nuking
your primary document.

As part of writing a @value{TWJR} program, you should also include
a @file{Makefile} in your document.  If you're wondering about
bootstrapping, then you're thinking ahead. We will get to that.

@node Why texinfo
@section Why Build On Top of Texinfo

Why Texinfo?  Good question, I'm glad you asked.

I have written books in @command{troff}, Texinfo, and DocBook (both SGML
and XML).  I have also written a little bit in straight HTML. Of all
of these, I find that Texinfo is the easiest to use.  It is expressive
enough for distinguishing the different kinds of things that need special
designation in a printed document, and for structuring a document in
the traditional way, without being so verbose that my fingers end up
hurting when I'm done working on a document after a few hours.

While my first preference might have been to use @command{noweb}, since I
am familiar with it, it does not support Texinfo. Even though @LaTeX{} is a
more powerful markup language, I didn't want to climb that learning curve
just to use @command{noweb}.  Also, I felt that it might be easier---and
certainly more @emph{fun}---to write my own small literate programming
system than to add a Texinfo back end to @command{noweb}.@footnote{The
truth is that doing something like this has been in the back of my mind
for close to 20 years; I finally decided to ``just do it.''}

Similarly, TexiWeb already does what I would seem to need, but its lack
of documentation makes it harder to use, and its enforced pretty-printing
is definitely undesirable for code not written in C. I prefer code to
look like code (constant-width font, no pretty-printing) and I want to be
able to use any kind of code in my code chunks, including @command{awk},
Makefiles, shell scripts, whatever.

Additionally, TexiWeb seems focused primarily on @TeX{}.  The advantage
of Texinfo is that it can be translated into HTML and also DocBook XML,
and I would like to preserve those advantages.

Finally, I think it's better for the author to do the indexing manually
than to rely on the literate programming tool, although that opinion
may change as this evolves.

@node Why awk
@section Why Implement In @command{awk}

Why write in @command{awk}? Good question. I glad you asked this one too.

I got involved with the
@uref{http://www.gnu.org/software/gawk/, GNU Awk project}
late in 1987.  I have been the sole maintainer and the primary author
of its documentation since 1994.  The language is small, elegant, and
generally quite powerful.  @command{gawk}, in particular, adds many
useful features over the original Unix (and POSIX standard) @command{awk}.

Part of what makes maintaining @command{gawk} enjoyable is that I like
using the language itself, on a daily basis.

Weaving and tangling primarily involve a lot of text manipulation, and
this is an area where @command{awk} shines. In particular, there's no
need to worry about low-level details like I/O and memory management;
the expression of what needs to be done has an almost one-to-one
correspondence to the code that does it!

@value{TWJR} gives me the opportunity to enjoy three of my favorite
activities all at the same time: writing with Texinfo, programming
in @command{gawk}, and doing that programming in the literate
style.@footnote{This may explain why so many literate programmers have
chosen to create their own literate programming systems.  So we now get
a little psychology thrown in as well.}

@node Example C Program
@chapter An Example C Progrm

To demonstrate the use of @value{TWJR}, here is a my very first
literate program (from 1998!), reworked to use TWJR.  I am going
to present the commentary (updated some) and the code, and then
follow it with the marked-up input.

In this @value{CHAPTER} I will use Texinfo unnumbered headings.
In a larger ``real'' document, I would use Texinfo nodes and
menues to fully structure the chapter.

@unnumberedsec Introduction

This is @command{echo}, Yet Another Implementation of the beloved Unix command.
It serves as a ``warm up exercise'' for me; my first literate program.

This version may or may not be POSIX-compliant, who cares?  It
echoes@footnote{Or is that ``echos?''.}
its arguments to @code{stdout}.  There are two possible options, the
traditional @option{-n}, to suppress the final newline, and @option{-e} to have
@command{echo} interpret escape sequences within the text.  A la System V
and now POSIX argument parsing conventions, use @option{--} on the command
line to get @command{echo} to treat any following arguments that begin with
a dash as literal text.

@unnumberedsec The High Level View

The program has the following outline.

@(echo.c@)=
@<includes@>
@<constant definitions@>
@<forward declarations@>
@<global variables@>
@<main program@>
@<other functions@>
@

@unnumberedsec And On With The Show

In a simple program like @command{echo}, it is often easiest to just
write out characters one at a time. For that, we will use the facilities
provided by the @code{<stdio.h>} header file.  Thus:

@<includes@>=
#include <stdio.h>
@

No other include files should be necessary.

Since C does not have a @code{bool} (boolean) type like C++ or Pascal,
we define some constants to improve readability.@footnote{This was written
before the C 99 standard added booleans to the language. We'll leave it
alone for now.}

@<constant definitions@>=
#define TRUE	1
#define FALSE	0
@

We need keep track of only two things at the global level: whether
we need to suppress the final newline, and whether or not we're
processing escape sequences. Initially, both are @code{FALSE}.

@<global variables@>=
int suppress_newline = FALSE;	/* no final newline if TRUE */
int do_escapes = FALSE;		/* process \x within strings */
@

@unnumberedsec The Main Program
The job here is pretty straightforward. First, process any command
line arguments, in order to set the values of the global flags
@code{suppress_newline} and @code{do_escapes}.  Then, loop over each
argument and print it out.

@<main program@>=
int
main(int argc, char **argv)
{
	@<local variables for main@>

	@<special case for no arguments@>
	@<process command line flags@>
	@<process remaining command line arguments@>
	exit(0);
}
@

If there are no arguments, @command{echo} can just print a newline
and return.

@<special case for no arguments@>=
if (argc == 1) {
	putchar('\n');
	exit(0);
}
@

To process the command line flags, we use the standard @code{getopt()}
routine.  The variables that @code{getopt()} manipulates are in the
@code{<unistd.h>} header file, so it seems we do need another header.
We also need a local variable to hold the result from each call to
@code{getopt()}.

Note that in the call to @code{getopt()}, neither @option{-e}
nor @option{-n} take an argument. Also note that no @code{default}
case is supplied, we just let @code{getopt()} print a message for us.

@<includes@>=
#include <unistd.h>	/* for getopt(3) machinery */
@

@<local variables for main@>=
int c;
@

@<process command line flags@>=
while ((c = getopt(argc, argv, "en")) != -1) {
	switch (c) {
	case 'e':
		do_escapes = TRUE;
		break;
	case 'n':
		suppress_newline = TRUE;
		break;
	}
}
@

Now it's time to get down to brass tacks, and do the work.
We either are doing escapes or we're not, so we key things
off of that decision first.  We'll need another local variable
for looping over the arguments, and we need a function that
handles the escape sequence processing.

@<local variables for main@>=
int i;	/* loop variable */
@

@<forward declarations@>=
extern void out_escape(const char *str);
@

@<process remaining command line arguments@>=
if (do_escapes) {
	for (i = optind; i < argc; i++) {
		out_escape(argv[i]);
		@<output a space if not the last argument@>
	}
} else {
	for (i = optind; i < argc; i++) {
		fputs(argv[i], stdout);
		@<output a space if not the last argument@>
	}
}
if (! suppress_newline)
	putchar('\n');
@

We print a single space in between arguments, but not after
the last one.

@<output a space if not the last argument@>=
if (i < argc-1)
	putchar(' ');
@

And that's it for the main logic.

@unnumberedsec Processing Escapes

The last thing to do is write the function that handles escape
sequences. For now, we won't bother with octal and hex escapes;
those are left as an exercise for the reader.

An initial version looks like this:

@<first version of @code{out_escape}@>=
void
out_escape(const char *str)
{
	register char *cp;

	for (cp = (char *) str; *cp != '\0'; cp++) {
		if (*cp != '\\') {
			putchar(*cp);	/* normal character */
			continue;
		}

		/* a \ seen, look at next character */
		switch (cp[1]) {
		case 'a':
			putchar('\a');
			cp++;
			break;
		case 'f':
			putchar('\f');
			cp++;
			break;
		case 'n':
			putchar('\n');
			cp++;
			break;
		case 'r':
			putchar('\r');
			cp++;
			break;
		case 't':
			putchar('\t');
			cp++;
			break;
		case 'v':
			putchar('\v');
			cp++;
			break;
		case '\\':
			putchar('\\');
			cp++;
			break;
		default:
			putchar('\\');
			break;
		}
	}
}
@

But that's rather long winded. A better way uses @code{strchr()} and
indexing to get the right character to print.

@<other functions@>=
void
out_escape(const char *str)
{
	static char texts[] = "abfnrtv";
	static char escapes[] = "\a\b\f\n\r\t\v";
	char *cp;
	int i;

	for (; *str != '\0'; str++) {
		if (*str != '\\' || str[1] == '\0') {
			putchar(*str);
			continue;
		}

		cp = strchr(texts, str[1]);
		if (cp != NULL) {
			i = (cp - texts);	/* get index */
			putchar(escapes[i]);
			str++;			/* skip the next char */
		} else if (str[1] == 'c') {
			/* a la troff: \c means no newline */
			suppress_newline = TRUE;
			str++;
		} else	/* do next char literally */
			putchar('\\');
	}
}
@

Interestingly enough, for this version I remembered @code{\b} and
also @code{\c}.

We also need to include the right header file to get @code{strchr()} declared.

@<includes@>=
#include <string.h>	/* for strchr(3) */
@

That's all folks!

@unnumberedsec Critques

Once the program is written and laid out, it becomes clear that
the special case for @samp{argc == 1} isn't needed; the behavior falls
out of the design and implementation.

The code at the end for suppressing the final newline should
probably be in a separate chunk, since it is conceptually separate
from the loops over the arguments.

Also, @code{getopt()} could be better documented, but I assume that most
people are familiar with it or can do @samp{man getopt} to get more
information.  Although argument parsing for @command{echo} could easily be
done by hand, using @code{getopt()} gives us standard, well defined
behavior, and the code is as short or shorter than doing it manually.

The @code{do_escapes} variable doesn't need to be global, after all,
although @code{suppress_newline} does.

Finally, octal and hexadecimal escapes ought to be implemented, but
for a first, example, program, I don't want to bother doing that, or
fixing the above other problems.

@unnumberedsec The Input For The Program

Here is the @value{TWJR} input for the preceding program.

@smallexample
@@unnumberedsec Introduction

This is @@command@{echo@}, Yet Another Implementation of the beloved Unix command.
It serves as a ``warm up exercise'' for me; my first literate program.

This version may or may not be POSIX-compliant, who cares?  It
echoes@@footnote@{Or is that ``echos?''.@}
its arguments to @@code@{stdout@}.  There are two possible options, the
traditional @@option@{-n@}, to suppress the final newline, and @@option@{-e@} to have
@@command@{echo@} interpret escape sequences within the text.  A la System V
and now POSIX argument parsing conventions, use @@option@{--@} on the command
line to get @@command@{echo@} to treat any following arguments that begin with
a dash as literal text.

@@unnumberedsec The High Level View

The program has the following outline.

@@(echo.c@@)=
@@<includes@@>
@@<constant definitions@@>
@@<forward declarations@@>
@@<global variables@@>
@@<main program@@>
@@<other functions@@>
@@

@@unnumberedsec And On With The Show

In a simple program like @@command@{echo@}, it is often easiest to just
write out characters one at a time. For that, we will use the facilities
provided by the @@code@{<stdio.h>@} header file.  Thus:

@@<includes@@>=
#include <stdio.h>
@@

No other include files should be necessary.

Since C does not have a @@code@{bool@} (boolean) type like C++ or Pascal,
we define some constants to improve readability.@@footnote@{This was written
before the C 99 standard added booleans to the language. We'll leave it
alone for now.@}

@@<constant definitions@@>=
#define TRUE    1
#define FALSE   0
@@

We need keep track of only two things at the global level: whether
we need to suppress the final newline, and whether or not we're
processing escape sequences. Initially, both are @@code@{FALSE@}.

@@<global variables@@>=
int suppress_newline = FALSE;   /* no final newline if TRUE */
int do_escapes = FALSE;     /* process \x within strings */
@@

@@unnumberedsec The Main Program
The job here is pretty straightforward. First, process any command
line arguments, in order to set the values of the global flags
@@code@{suppress_newline@} and @@code@{do_escapes@}.  Then, loop over each
argument and print it out.

@@<main program@@>=
int
main(int argc, char **argv)
@{
    @@<local variables for main@@>

    @@<special case for no arguments@@>
    @@<process command line flags@@>
    @@<process remaining command line arguments@@>
    exit(0);
@}
@@

If there are no arguments, @@command@{echo@} can just print a newline
and return.

@@<special case for no arguments@@>=
if (argc == 1) @{
    putchar('\n');
    exit(0);
@}
@@

To process the command line flags, we use the standard @@code@{getopt()@}
routine.  The variables that @@code@{getopt()@} manipulates are in the
@@code@{<unistd.h>@} header file, so it seems we do need another header.
We also need a local variable to hold the result from each call to
@@code@{getopt()@}.

Note that in the call to @@code@{getopt()@}, neither @@option@{-e@}
nor @@option@{-n@} take an argument. Also note that no @@code@{default@}
case is supplied, we just let @@code@{getopt()@} print a message for us.

@@<includes@@>=
#include <unistd.h> /* for getopt(3) machinery */
@@

@@<local variables for main@@>=
int c;
@@

@@<process command line flags@@>=
while ((c = getopt(argc, argv, "en")) != -1) @{
    switch (c) @{
    case 'e':
        do_escapes = TRUE;
        break;
    case 'n':
        suppress_newline = TRUE;
        break;
    @}
@}
@@

Now it's time to get down to brass tacks, and do the work.
We either are doing escapes or we're not, so we key things
off of that decision first.  We'll need another local variable
for looping over the arguments, and we need a function that
handles the escape sequence processing.

@@<local variables for main@@>=
int i;  /* loop variable */
@@

@@<forward declarations@@>=
extern void out_escape(const char *str);
@@

@@<process remaining command line arguments@@>=
if (do_escapes) @{
    for (i = optind; i < argc; i++) @{
        out_escape(argv[i]);
        @@<output a space if not the last argument@@>
    @}
@} else @{
    for (i = optind; i < argc; i++) @{
        fputs(argv[i], stdout);
        @@<output a space if not the last argument@@>
    @}
@}
if (! suppress_newline)
    putchar('\n');
@@

We print a single space in between arguments, but not after
the last one.

@@<output a space if not the last argument@@>=
if (i < argc-1)
    putchar(' ');
@@

And that's it for the main logic.

@@unnumberedsec Processing Escapes

The last thing to do is write the function that handles escape
sequences. For now, we won't bother with octal and hex escapes;
those are left as an exercise for the reader.

An initial version looks like this:

@@<first version of @@code@{out_escape@}@@>=
void
out_escape(const char *str)
@{
    register char *cp;

    for (cp = (char *) str; *cp != '\0'; cp++) @{
        if (*cp != '\\') @{
            putchar(*cp);   /* normal character */
            continue;
        @}

        /* a \ seen, look at next character */
        switch (cp[1]) @{
        case 'a':
            putchar('\a');
            cp++;
            break;
        case 'f':
            putchar('\f');
            cp++;
            break;
        case 'n':
            putchar('\n');
            cp++;
            break;
        case 'r':
            putchar('\r');
            cp++;
            break;
        case 't':
            putchar('\t');
            cp++;
            break;
        case 'v':
            putchar('\v');
            cp++;
            break;
        case '\\':
            putchar('\\');
            cp++;
            break;
        default:
            putchar('\\');
            break;
        @}
    @}
@}
@@

But that's rather long winded. A better way uses @@code@{strchr()@} and
indexing to get the right character to print.

@@<other functions@@>=
void
out_escape(const char *str)
@{
    static char texts[] = "abfnrtv";
    static char escapes[] = "\a\b\f\n\r\t\v";
    char *cp;
    int i;

    for (; *str != '\0'; str++) @{
        if (*str != '\\' || str[1] == '\0') @{
            putchar(*str);
            continue;
        @}

        cp = strchr(texts, str[1]);
        if (cp != NULL) @{
            i = (cp - texts);   /* get index */
            putchar(escapes[i]);
            str++;          /* skip the next char */
        @} else if (str[1] == 'c') @{
            /* a la troff: \c means no newline */
            suppress_newline = TRUE;
            str++;
        @} else /* do next char literally */
            putchar('\\');
    @}
@}
@@

Interestingly enough, for this version I remembered @@code@{\b@} and
also @@code@{\c@}.

We also need to include the right header file to get @@code@{strchr()@} declared.

@@<includes@@>=
#include <string.h> /* for strchr(3) */
@@

That's all folks!

@@unnumberedsec Critques

Once the program is written and laid out, it becomes clear that
the special case for @@samp@{argc == 1@} isn't needed; the behavior falls
out of the design and implementation.

The code at the end for suppressing the final newline should
probably be in a separate chunk, since it is conceptually separate
from the loops over the arguments.

Also, @@code@{getopt()@} could be better documented, but I assume that most
people are familiar with it or can do @@samp@{man getopt@} to get more
information.  Although argument parsing for @@command@{echo@} could easily be
done by hand, using @@code@{getopt()@} gives us standard, well defined
behavior, and the code is as short or shorter than doing it manually.

The @@code@{do_escapes@} variable doesn't need to be global, after all,
although @@code@{suppress_newline@} does.

Finally, octal and hexadecimal escapes ought to be implemented, but
for a first, example, program, I don't want to bother doing that, or
fixing the above other problems.
@end smallexample

@node jrtangle code
@chapter Tangling: The @command{jrtangle} Program

The major additional syntactic features over Texinfo are @dfn{file chunks}
and @dfn{code chunks}. Each starts with the name of the chunk in special
bracketing sequences, and continues until a line with just a single
@samp{@@} sign on it.

@table @code
@item @@(@var{filename}@@) =
Start or add to the definition of @var{filename}'s contents.

@item @@<@var{chunkname}@@> =
Start or add to the definition of a code chunk named @var{chunkname}.
@end table

@quotation NOTE
Due to the implementation of both programs, file chunks and code
chunks share the same ``name space,'' meaning that you will
cause severe confusion if you attempt to use the same name
as a source file name and as a code chunk name.
@end quotation

@menu
* jrtangle header::             Getting Started.
* jrtangle ifweave iftangle::   Text inclusion/exclusion for
                                @command{jrtangle}.
* jrtangle texinfo vars::       Using Texinfo variables in code.
* jrtangle handle ignore::      Handling @code{@@ignore} lines.
* jrtangle file chunks::        Processing file chunks for @command{jrtangle}.
* jrtangle code chunks::        Processing code chunks for @command{jrtangle}.
* jrtangle error checking::     Checking for errors in @command{jrtangle}.
* Expanding code chunks::       Expanding code chunks into straight code.
* jrtangle expanding values::  
* jrtangle before everything::  Doing something before extracting any files.
* jrtangle avoiding update::    Leaving unmodified files alone.
* jrtangle shell debug::        Debugging shell commands run by
                                @command{jrtangle}.
* jrtangle after creation::     Doing something after creating a file.
* Common Chunks::               Common code chunks and functions.
@end menu

@node jrtangle header
@section Getting Started

Let's get started.  Here is the code for @command{jrtangle}.

The file starts with the obligatory @samp{#!} header and copyright
statements, followed by code chunks and functions common to both
@command{jrtangle} and @command{jrweave}.

This is the first file chunk we've seen. @value{TWJR}
automatically adds cross reference information after each
chunk. For code chunks, the information is:

@itemize @bullet
@item
A list of other places where the chunk is defined.

@item
A statement or list of other chunks that call this chunk.

@item
A statement or list pointing to the first definition of
any chunk that is called by this chunk.
@end itemize

File chunks, by default, do not include the list other definition
points since this list tends to be voluminous and not of much
value. It can be enabled if necessary (@pxref{jrweave additional macros}).

@cindex @code{@@post_create} command, @command{jrtangle}
@post_create jrtangle chmod +x jrtangle
@(jrtangle@) =
@<Shebang header@>
@<Common Chunks@>
@<Helper Functions@>
@

On modern systems, the latest version of @command{gawk} lives
in @file{/usr/bin}. This should be changed on
your system if it's not correct.

@<Shebang header@>=
#! /usr/bin/gawk -f
@

The common chunks and functions are described later in this @value{CHAPTER}.
However, we define some of them now, so that the license comes
out at the top of the file. The actual license text is provided later.

@<Common Chunks@>=
@<GPL 3 Copyright statement@>
@<Source Code Repository Web Info@>
@<Check @command{gawk} version@>
@

As a general note, @command{jrtangle} and @command{jrweave} need features
introduced in @command{gawk} 4.0; @emph{earlier versions will not work}.
Since this is particularly important for @command{jrtangle}, we
check for it. (This chunk was provided by the Texinfo maintainers.)

@<Check @command{gawk} version@>=
BEGIN {
	v[0] = 0
	if ("version" in PROCINFO) {
		match(PROCINFO["version"], /^[0-9]+\./, v);
	}

	if (v[0] < 4) {
		print("gawk >= 4.0 required") > "/dev/stderr"
		exit 63	# for "missing" script
	}
}
@


@node jrtangle ifweave iftangle
@section Document Sections Exclusive to Tangling and Weaving

One nice thing in TexiWeb are @samp{@@iftangle @r{@dots{}} @@end iftangle} and
@samp{@@ifweave @r{@dots{}} @@end ifweave} bracketing commands.  Those should
be dealt with early on.  They do the obvious thing: include lines that
should be used only for one operation or the other.  Note that these
have to be done differently for @command{jrtangle} and @command{jrweave};
each one ignores what the other one passes through.

@(jrtangle@) =
@<Handle @code{ifweave} and @code{iftangle} for @code{jrtangle}@>
@

@cindex global variables, name convention
The following code is straightforward. We see here the first instance
of any global variables: @code{Line_numbers}. Instead of having lots
of different global variables, they are grouped by function into
associative arrays.  Here we see @code{Line_numbers["ifweave"]}
and @code{Line_numbers["iftangle"]} to help in error checking. If an
@code{@@ifweave} block is encountered while @command{jrtangle} thinks
it's processing an @code{@@iftangle} block, then something got messed
up somewhere.  Note also the convention that global variables start with
a capital letter.

@vindex @code{Line_numbers} variable
@vindex variable, @code{Line_numbers}
@cindex @code{@@ifweave} command, @command{jrtangle}
@cindex @code{@@iftangle} command, @command{jrtangle}

@<Handle @code{ifweave} and @code{iftangle} for @code{jrtangle}@>=
# ifweave lines should be removed

/^@ifweave[[:space:]]*$/, /^@end ifweave[[:space:]]*$/ {
	if ("iftangle" in Line_numbers)
		fatal(_"cannot nest @ifweave inside @iftangle\n")

	# start of construct, save line number
	if (/^@ifweave[[:space:]]*$/)
		Line_numbers["ifweave"] = (FILENAME ":" FNR)

	# end of construct, delete line number
	if (/^@end ifweave[[:space:]]*$/)
		delete Line_numbers["ifweave"]

	# simply skip these lines, this is tangling
	next
}

# For tangling we remove the bracketing control lines and let anything
# in between fall through.

/^@iftangle[[:space:]]*$/, /^@end iftangle[[:space:]]*$/ {
	if ("ifweave" in Line_numbers)
		fatal(_"cannot nest @iftangle inside @ifweave\n")

	# start of construct, save line number, skip this line
	if (/^@iftangle[[:space:]]*$/) {
		Line_numbers["iftangle"] = (FILENAME ":" FNR)
		next
	}

	# end of construct, delete line number, skip this line
	if (/^@end iftangle[[:space:]]*$/) {
		delete Line_numbers["iftangle"]
		next
	}

	# otherwise fall through into the rest of the code
}
@

@node jrtangle texinfo vars
@section Using Texinfo Variables In Code

Texinfo provides a simple variable-substitution facility. You se
@samp{@@set @var{variable} @var{value}} to set a variable and
@samp{@@value@{@var{variable}@}} to put the variable's value
into the text being formatted.

It would be nice to have such things work for the generated
code too. In the formatted document, this would happen automatically.
But the code must be processed specially if this is to work.

Two obvious uses that come to mind for such a facility
are including version numbers in the code, as well as something
like the date and time that the code was extracted from the
@value{TWJR} source file.

@(jrtangle@) =
@<Process @code{@@set} lines@>
@

@<Process @code{@@set} lines@>=
$1 == "@set" {
	var_name = $2			# get the variable name
	$1 = $2 = ""			# remove @set and variable name
	gsub(/(^[[:space:]]*)|([[:space:]]*$)/, "", $0)
	Values[var_name] = $0	# save the value
	next
}
@

The substitution of values into output code lines is handled
later; see @xref{jrtangle expanding values}.

@node jrtangle handle ignore
@section Handling @code{@@ignore} Lines

In a regular Texinfo document, lines bracketed between @samp{@@ignore}
and @samp{@@end ignore} are ignored.  During development, it would be
good if @command{jrtangle} and @command{jrweave} also did so, in case
it's desirable to ``comment out'' chunks that are still half-baked

@(jrtangle@) =
@<Handle lines between @code{@@ignore} and @code{@@end ignore}@>
@

@<Handle lines between @code{@@ignore} and @code{@@end ignore}@>=
/^@ignore/, /^@end ignore/ { next }
@

@node jrtangle file chunks
@section Processing File Chunks for @command{jrtangle}

The next part of interest is to handle file chunks. File chunks
specify the name of a file and include straight code intermixed with
references to code chunks.

@menu
* jrtangle start chunk collection::  Starting chunk collection.
* jrtangle finish chunk collection:: Finishing file and code chunk collection.
* jrtangle collecting chunk lines::  Collecting chunk lines.
* jrtangle finish file chunk::       Completing file collection for
                                     @command{jrtangle}.
@end menu

@node jrtangle start chunk collection
@subsection Starting File and Code Chunk Collection

File chunks include straight code mixed with references to code chunks.
It turns out that because code chunks @emph{also} include straight code mixed
with references to code chunks, their processing is quite similar to
that of file chunks.  After fully implementing @command{jrtangle} and
almost fully implementing @command{jrweave}, it became clear that I was
using a lot of similar-but-not-quite-identical code in several places,
and that it would be better to go back and unify the processing of the
two kinds of chunks. This would ultimately simplify the final code;
any remaining duplication would come from reuse of code chunks instead
of from copy-paste-edit.

We start by placing the two patterns that search for chunks one right
after the other; they are then followed by the code that terminates
collection (for the standalone @samp{@@} sign) and the collection code.
This is purposely similar to an @command{awk} range pattern.
We will see the code chunk processing in @ref{jrtangle code chunks}.

@(jrtangle@) =
@<Initial code chunk processing pattern for @command{jrtangle}@>
@<Initial file chunk processing pattern for @command{jrtangle}@>
@<Handle terminating at-sign for file and code chunks@>
@<Collect chunk lines@>
@

As mentioned, file chunks start with @samp{@w{@@(filename.c@@) =}} in column
1. Unlike TexiWeb and like @command{noweb}, we don't require @samp{+=}
to add more stuff to a definition. We just use @samp{=} and figure it
out. File and code chunks end with a single @samp{@@} on a line by itself,
with the @samp{@@} in column 1.

The variable @code{File_chunk_pattern} describes the regexp for matching
the first line of a file chunk. It is a variable since it needs to be
used for matching and with @code{gensub()}. This is better than repeating
the regexp in the code.

@<Definition of @code{File_chunk_pattern}@> =
File_chunk_pattern = "^@\\(([^)]+)@\\)[[:space:]]*=[[:space:]]*$"
@

It turns out that file chunk processing has some common bits
for both @command{jrtangle} and @command{jrweave}.

@<Initial file chunk processing pattern for @command{jrtangle}@>=
$0 ~ File_chunk_pattern {
	@<Common file chunk initial processing@>
	next
}
@

In turn, the file processing shares code with the code chunk processing by
putting the appropriate values into variables used while collecting both
kinds of chunks.

@<Common file chunk initial processing@> =
Chunk_type = "file chunk"
Pattern = File_chunk_pattern
Debug_pat = "filename"
@<Common chunk initial processing@>
@

Instead of using a range pattern, we use a boolean flag; this lets us
avoid special-casing the first and last lines.

@vindex @code{Flags} variable
@vindex variable, @code{Flags}
The code checks that
we're not already gathering a chunk; if we are, someone left off a trailing
@samp{@@} somewhere. The @code{check_unfinished()} function also checks other
possible things that may have gone wrong.
Similar to @code{Line_numbers}, @code{Flags} is a global array of
flags (boolean values) indexed by strings indicating what we're doing.

@vindex @code{Debug} variable
@vindex variable, @code{Debug}
@cindex debugging, @code{Debug} variable
The check against @code{Debug} uses a nice trick. By using
@command{gawk}'s @option{-v} option, we can set @code{Debug} to any value,
such as @samp{filename code} and debug as many different aspects of
the program simultaneously as we might want.  Use of the @command{gawk}
built-in debugger also helps considerably.

@<Common chunk initial processing@> =
new_chunk = gensub(Pattern, "\\1", 1)
if (Flags[Chunk_type]) {
	fatal(_"%s start of %s found while still collecting %s\n",
		Chunk_type, new_chunk, Current_chunk)
}
check_unfinished()

Flags[Chunk_type] = TRUE
Line_numbers[Chunk_type] = (FILENAME ":" FNR)
Current_chunk = new_chunk
Chunk_info[Current_chunk]["type"] = Chunk_type

if (Debug ~ Debug_pat)
	printf("saw new %s %s\n", Debug_pat, Current_chunk) > "/dev/stderr"
@

The @code{BEGIN} block sets up some constants.

@<Common Chunks@>=
BEGIN {
	@<Constants used by @command{jrtangle} and @command{jrweave}@>
}
@

And here is the first set of constants:

@<Constants used by @command{jrtangle} and @command{jrweave}@> =
TRUE = 1
FALSE = 0
@<Definition of @code{File_chunk_pattern}@>
@

@node jrtangle finish chunk collection
@subsection Finishing File and Code Chunk Collection

Here is the @samp{@@} sign that ends the input file.  It also ends
code chunks.  Since we are manually simulating a range pattern, this
@emph{must} come before the code that collects the lines in file and
code chunks. Otherwise the collection never stops!@footnote{Guess
how I discovered that one@enddots{} Duh.}

Here too, what to do upon seeing the terminating @samp{@@} is shared
across @command{jrtangle} and @samp{jrweave}.

@<Handle terminating at-sign for file and code chunks@> =
/^@[[:space:]]*$/ {
	if (Flags["file chunk"])
		end_file_gathering()
	else if (Flags["code chunk"])
		end_code_gathering()
	else
		warning(_"unmatched terminating @-sign: ignored\n")

	Chunk_lines = ""
	Flags[Chunk_type] = FALSE
	Line_numbers[Chunk_type] = ""
	Chunk_type = ""

	next
}
@

@node jrtangle collecting chunk lines
@subsection Collecting Chunk Lines

After some experimentation, things are simplest if file contents and
code chunks do @emph{not} have the final terminating newline. Code that
outputs file contents must remember to add the final newline.

Collecting the lines is simple.
Collect each line and append it.
Any embedded code chunks are expanded at the end.
Collecting lines is also common between the two programs.

@<Collect chunk lines@> =
Flags["file chunk"] || Flags["code chunk"] {
	if (Chunk_lines == "")
		Chunk_lines = $0
	else
		Chunk_lines = Chunk_lines "\n" $0

	next
}
@

@node jrtangle finish file chunk
@subsection Completing File Collection for @command{jrtangle}

Once we have all the lines, we save them in @code{File_contents},
which is an associative array whose indices are the file names
and the corresponding values are each file's lines.

@(jrtangle@) =
@<Process file chunks for @code{jrtangle}@>
@

@findex @code{end_file_gathering()} function, @command{jrtangle}
@<Process file chunks for @code{jrtangle}@>=
# end_file_gathering ---finish up collecting a file

function end_file_gathering()
{
	if (Current_chunk in File_contents)
		File_contents[Current_chunk] = \
			File_contents[Current_chunk] "\n" Chunk_lines
	else
		File_contents[Current_chunk] = Chunk_lines

	if (Debug ~ /filename/)
		printf("finished collecting file %s\n",
						Current_chunk) > "/dev/stderr"
}
@

@node jrtangle code chunks
@section Processing Code Chunks for @command{jrtangle}

The next major piece of logic is the collection of code chunks.

@(jrtangle@) =
@<Process code chunks for @code{jrtangle}@>
@

Code chunks are like file chunks. They start with @samp{@@<chunk-name@@>
=} and end with a standalone @samp{@@} sign. The logic and handling are
essentially identical to what we just did for files, especially now that
we are sharing code.

First the pattern to match.  My initial attempt at a pattern was:

@c set it off since it's too long for being embedded inline
@example
^@@<([^@@]+)@@>[[:space:]]*=[[:space:]]*$
@end example

@noindent
However, this didn't work as soon as I used a chunk name that included Texinfo
commands.  Ooops.  So now the pattern is more general.

Since we have to bootstrap from this file, and @samp{@@<(.+)@@>}
looks like a code chunk name, we create the pattern using string concatenation:

@<Constants used by @command{jrtangle} and @command{jrweave}@> =
Code_chunk_pattern = "^@" "<(.+)" "@>[[:space:]]*=[[:space:]]*$"
@

Next the logic. Here too, there are common bits shared between
@command{jrtangle} and @command{jrweave}:

@<Initial code chunk processing pattern for @command{jrtangle}@> =
$0 ~ Code_chunk_pattern {
	@<Common code chunk initial processing@>
	next
}
@

@<Common code chunk initial processing@> =
Chunk_type = "code chunk"
Pattern = Code_chunk_pattern
Debug_pat = "code"
@<Common chunk initial processing@>
@

What to do after gathering the lines depends upon the program.
For @command{jrtangle} we store the lines for later use.

@findex @code{end_code_gathering()} function, @command{jrtangle}
@<Process code chunks for @code{jrtangle}@>=
# end_code_gathering --- complete collecting lines of the code chunk

function end_code_gathering()
{
	if (Current_chunk in Code_contents)
		Code_contents[Current_chunk] = \
			Code_contents[Current_chunk] "\n" Chunk_lines
	else
		Code_contents[Current_chunk] = Chunk_lines

	if (Debug ~ /code/)
		printf("finished collecting %s\n",
					Current_chunk) > "/dev/stderr"
}
@

And that's it!  The chunk collection and chunk termination code
should handle code chunks as well.

@node jrtangle error checking
@section Checking for Errors

Here is the error checking code. First add it to both files:

@<Common Chunks@>=
# Error checking:

# Use brackets to avoid triggering the warning on ourselves!
/(^<[@])|(>[@]([[:space:]]*=[[:space:]]*)?$)/	{
	# Ditto, with concatenation
	warning("<" "@ or >" "@ used instead of @" "< or @" ">\n\t%s\n",
			$0)
}

END {
	check_unfinished()
}
@


There are two classes  of helper functions used in expanding code chunks;
those needed in both @command{jrtangle} and @command{jrweave}, and those
needed just for @command{jrtangle}.

Checking for unfinished chunks is the same for both @command{jrtangle}
and @command{jrweave}. This is the first of the shared helper functions,
@code{check_unfinished()}.  We will see more functions later.

@findex @code{check_unfinished()} function
@<Helper Functions@> =
# check_unfinished --- print a fatal error when an unfinished code or
#			file chunk is detected. Also ifweave / iftangle.

function check_unfinished()
{
	if (Flags["file chunk"])
		fatal(_"unfinished file chunk (started at %s)\n",
			Line_numbers["file chunk"])
	else if (Flags["code chunk"])
		fatal(_"unfinished code chunk (started at %s)\n",
			Line_numbers["code chunk"])

	if ("ifweave" in Line_numbers)
		fatal(_"unfinished @ifweave section (started at %s)\n",
			Line_numbers["ifweave"])

	if ("iftangle" in Line_numbers)
		fatal(_"unfinished @iftangle section (started at %s)\n",
			Line_numbers["iftangle"])
}
@

@node Expanding code chunks
@section Expanding Code Chunks

Expanding code chunks is the hardest part of @command{jrtangle}.
In particular, any expanded chunks may contain other chunks that
need expanding. This naturally leads to a recursive implementation,
which in turn requires checking that a code chunk's expansion
does not include itself, either directly or indirectly.

Experimentation has shown that it's necessary to manage the
recursion carefully; after a chunk has been expanded we must
clear our record of it. For example, consider a chunk like this:

@noindent
@:<@i{example chunk} @oldnum{42}> @equiv{}
@example
x = func1()
@r{<@i{Do special task} @oldnum{57}>}
y = func2()
@r{<@i{Do special task} @oldnum{57}>}
@dots{}
@end example

@noindent
After expanding @code{@@<Do special task@@>} the first time, we have
to forget that we've done it, so that we can safely expand it the
second time.

@(jrtangle@) =
@<Expand code chunks@>
@

We will work through the code top down:

@<Expand code chunks@>=
# Finishing off code is easy, at least from 10,000 feet.

END {
	@<Do any initial setup@>

	dump_files()

	if (Debug ~ /code/)
		dump_chunks()
}
@

Of course, we have delayed the inevitable only a little bit.  At the
outermost level, the code loops through all the files and writes them out,
letting @code{expand_code_chunks()} do the real work.

In practice, if a source file's contents haven't changed we don't want
to write them out again, since this could easily cause @command{make}
to recompile a file that doesn't need recompiling. In large programs
this is a Bad Thing. (The @code{update_recipe} array used in the following
chunk takes care of this; for explanation, @pxref{jrtangle avoiding update}).

As a side note, it may be that dumping all the files every time is a
bad idea. If experience shows us that this is so, this is where to make
the change, along with new code to take a command-line option indicating
which file(s) to extract.

@findex @code{dump_files()} function, @command{jrtangle}
@<Expand code chunks@>=
# dump_files --- create files and update them as needed

function dump_files(	i, s, update_recipe)
{
	for (i in File_contents) {
		s = expand_code_chunks(File_contents[i])

		create_update_recipe(i, update_recipe)
		printf("%s\n", s) > update_recipe["output"]
		close(update_recipe["output"])

		# update the file if necessary
		update_recipe["recipe"] = (Shell_debug update_recipe["recipe"])
		system(update_recipe["recipe"])

		@<Run ``post create'' commands@>
	}
}
@

@noindent
(The @code{Shell_debug} variable is discussed in @ref{jrtangle shell debug}.)

In turn, @code{expand_code_chunks()} initializes for recursion checking
and then passes the buck to @code{do_expand_code_chunks()}.

@findex @code{expand_code_chunks()} function, @command{jrtangle}
@<Expand code chunks@>=
# expand_code_chunks --- expand embedded code chunks.

function expand_code_chunks(contents)
{
	@<Reset for recursion@>

	return do_expand_code_chunks(contents)
}
@

By the time we get here, it isn't actually so hard.
@code{do_expand_code_chunks()} splits the contents into individual
lines. It then loops over the results.  If a line does not contain any
chunk names, then the result can be kept verbatim, and it is copied into
the @code{results} array.

On the other hand, if it does, it has to be expanded, and that is done
down in @code{expand_one_line()}.

@findex @code{do_expand_code_chunks()} function, @command{jrtangle}
@<Expand code chunks@>=
# do_expand_code_chunks --- do the actual work to expand code chunks

function do_expand_code_chunks(contents,
								nlines, lines, results, i, j) # locals
{
	nlines = split(contents, lines, "\n")

	for (i = 1; i <= nlines; i++) {
		if (lines[i] !~ Chunk_name_pattern) {
			results[i] = lines[i]
		} else
			results[i] = expand_one_line(lines[i])
	}

	@<Expand @code{@@value} instances in the code@>

	return join(results, 1, nlines, "\n")
}
@

Expanding instances of @code{@@value} is handled further on;
see @xref{jrtangle expanding values}.

Let's go ahead and define @code{Chunk_name_pattern}, which is
used throughout the expansion process.

@<Constants used by @command{jrtangle} and @command{jrweave}@> =
Chunk_name_pattern = "@<[^>\n]+@>"
@

@code{expand_one_line()} does all the work to isolate chunk names, expand
them, and put everything back together with reasonable indentation.
At the end, if the expanded line contains further code chunks, it
recursively calls @code{do_expand_code_chunks()} to process them as well.

@findex @code{expand_one()} function, @command{jrtangle}
@<Expand code chunks@>=
# expand_one_line --- expand a line with code chunk references

function expand_one_line(input_line,	parts, chunk_names, nparts,
										num_names, code_lines, i, j)
{
	@<Split the input line into text parts and chunk names@>
	@<Check for recursive expansion@>
	@<Get the code lines, insert white space if needed@>
	@<Put the line back together, expanding code chunks along the way@>

	if (code_lines ~ Chunk_name_pattern) {
		# get any further code chunks, recursively
		return do_expand_code_chunks(code_lines)
	} else
		return code_lines
}
@

The following code uses the four-argument version of @code{split()};
the fourth argument is an array of strings where each element is what
matched the separating regexp.  Element @var{i} in the @code{chunk_names}
array is what came after element @var{i} in the @code{parts} array.

@<Split the input line into text parts and chunk names@> =
nparts = split(input_line, parts, Chunk_name_pattern, chunk_names)
num_names = length(chunk_names)
@

In our case, the split is made using @code{Chunk_name_pattern}, causing
@code{parts} to contain the parts of the line before and after each
chunk name. The fourth argument, @code{chunk_names}, contains the
names of the code chunks and there is more than one element if
there were several chunks referenced on the line.  @code{num_names}
tells us how many chunk names there are.

After splitting, error checking looks to see if the chunk name
is @emph{not} in @code{Code_contents}; if so, then it was never
defined. (That is also an error.)  Next, it checks to see if any of the
found chunk names are already in the process of being expanded. This is
done using a global array named @code{Currently_expanding}.  If present,
it's an error; otherwise the name is entered into the array.

@use_smallexample
@<Check for recursive expansion@> =
# check for recursive expansion
for (i = 1; i <= num_names; i++) {
	j = strip_out_name(chunk_names[i])

	if (! (j in Code_contents))
		fatal(_"expand_one_line: code chunk `%s' used but not defined\n",
			chunk_names[i])

	if (j in Currently_expanding)
		fatal(_"expand_one_line: code chunk `%s' expands itself recursively\n",
			chunk_names[i])
	else
		Currently_expanding[j] = TRUE
}
@
@use_example

And way back up in @code{expand_code_chunks()}, we have to empty out the
@code{Currently_expanding} array:

@<Reset for recursion@> =
delete Currently_expanding
@

Here is the next shared helper function, @code{strip_out_name()},
which pulls out the name of the chunk from in between the @samp{@@<}
and the @samp{@@>}:

@findex @code{strip_out_name()} function
@<Helper Functions@>=
# strip_out_name --- get the name from name

function strip_out_name(name,	l)
{
	l = length(name)
	name = substr(name, 3, l - 4)

	return name
}
@

Returning to processing code lines, we start by getting the code associated
with the first chunk.  If the part of the line preceding the first chunk
reference is all white space, we insert that part in front of the text
of each retrieved line. The result is that indentation in the finished,
generated code, looks reasonable.

This too is an explicit design decision. Knuth's original @command{TANGLE}
made the generated code as ugly as possible so that there would be no
temptation to work with it directly.  I don't want to be so draconian.
In particular, when using the @command{gawk} debugger, it really helps
that the code is formatted nicely.

After getting the code body for each chunk we delete it from the
@code{Currently_expanding} array.  This is where we ``forget'' that
we're expanding the chunk for the recursion check.

@<Get the code lines, insert white space if needed@> =
code_lines = code_body(chunk_names[1])
delete Currently_expanding[strip_out_name(chunk_names[1])]

if (input_line !~ ("^" Chunk_name_pattern)) {
	if (parts[1] ~ /^[[:space:]]+$/) {
		# insert leading white space on all lines to get indentation
		gsub(/^|\n/, ("&" parts[1]), code_lines)
	} else {
		code_lines = parts[1] code_lines
	}
}
@

Reassembling the lines is straightforward, the parts are concatenated
with the expansion of the chunks.

@<Put the line back together, expanding code chunks along the way@> =
for (i = 2; i <= nparts; i++) {
	code_lines = code_lines parts[i]
	if (i in chunk_names) {
		code_lines = code_lines code_body(chunk_names[i])
		delete Currently_expanding[strip_out_name(chunk_names[i])]
	}
}
@

We now encounter the first of the helper functions that
are only used by @command{jrtangle}.

@<Expand code chunks@>=
@<Expansion helper functions@>
@

The @code{code_body()} function retrieves the code associated
with a chunk name. Since @code{Code_contents} is indexed by chunk names
without the enclosing brackets, this just strips them off using
@code{strip_out_name()}.

@findex @code{code_body()} function, @command{jrtangle}
@<Expansion helper functions@> =
# code_body --- get the code body associated with name

function code_body(name)
{
	return Code_contents[strip_out_name(name)]
}
@

@node jrtangle expanding values
@section Expanding @code{@@value} In Code Lines

Before returning the expanded code lines, we have to see if there
are any instances of @samp{@@value@{@var{variable}@}} in them.
To do that we make a separate pass over the lines:

@<Expand @code{@@value} instances in the code@>=
for (i = 1; i in results; i++)
	results[i] = expand_value(results[i])
@

@<Expansion helper functions@> =
function expand_value(text,		parts, seps, i, n, var, result)
{
	if (index(text, "@value") == 0)
		return text

	n = split(text, parts, /@value\{[^}]+\}/, seps)

	for (i in seps) {
		var = gensub(/@value\{([^}]+)\}/, "\\1", 1, seps[i])
		seps[i] = Values[var]
	}

	result = seps[0]	# "" or real
	for (i = 1; i in parts; i++)
		result = result parts[i] seps[i]

	return result
}
@

@node jrtangle before everything
@section Doing Something Before Extracting Any Files

If a @value{TWJR} document describes many source files, it is
logical to want to have subdirectories of different kinds for
different files, and perhaps to run some kind of configuration
or other initialization programs.  To that end, the author of
the document can provide a script (or command invoking a script)
bracketed by @samp{@@initial_setup @r{@dots{}} @@end initial_setup} lines.

Such lines must first be gathered, using the now familiar collection
pattern:

@(jrtangle@) =
@<Collect initial setup lines@>
@

@<Collect initial setup lines@>=
/^@initial_setup[[:space:]]*$/, /^@end initial_setup[[:space:]]*$/ {
	if (/^@initial_setup[[:space:]]*$/) {
		# start of construct, save line number, skip this line
		if ("initial_setup" in Line_numbers)
			fatal(_"cannot nest one @initial_setup inside another\n")
		Line_numbers["initial_setup"] = (FILENAME ":" FNR)
		Initial_setup = ""
	} else if (/^@end initial_setup[[:space:]]*$/) {
		# end of construct, delete line number, skip this line
		delete Line_numbers["initial_setup"]
	} else
		Initial_setup = Initial_setup "\n" $0

	next
}
@

As a result of the @samp{Initial_setup = ""} statement, the last such section
``wins.''  I don't see a reason to make this something that accumulates.

Besides giving the user control over the initial setup, this scheme has the
advantage of being OS-independent; a Windows user can write batch commands
in such a section, whereas a user on a POSIX system can write a shell script,
and @command{gawk} doesn't have to care.

In the @code{END} block that dumps the file, we run the command collected
in @code{Initial_setup}.  Note that it is up to the author of the program
to make sure that the commands are safe to run multiple times in a row.
For example, when creating directories, it is better to write something like
this:

@c manually expand tabs here!
@example
for i in src doc support @r{@dots{}}
do
    if [ ! -d $i ]
    then
        mkdir $i
    fi
done
@end example

@noindent
The above loop checks that each directory does not exist before
creating it.

Just in case, we append a final newline to the text of
@code{Initial_setup}.  Running the @code{Initial_setup} is easy:

@<Do any initial setup@>=
if (length(Initial_setup) > 0) {
	Initial_setup = Initial_setup "\n"
	system(Shell_debug Initial_setup)
}
@

@node jrtangle avoiding update
@section Leaving Unmodified Files Alone

When working with @command{make}, especially in large programs,
it is vital that source files be recompiled only if they have
changed. If @command{jrtangle} blindly recreates every
file every time it runs, @command{make} will constantly
recompile everything from scratch.  This could potentially be
a huge waste of time, even on today's very fast multicore
processors.  So, we have to find some way to only revise
a file on disk when it has actually changed.

This should get interesting.  First, let's talk about 
what @command{noweb} does.  To extract a file, you
tell @command{notangle} which file you are interested in,
and it prints the file contents to standard output. Said
contents may be redirected straight into the destination file.
Or they may be passed to a special program named @command{cpif}
(``copy if'') that compares the new contents to those of the
existing file on disk.  It goes something like this:

@example
notangle -Rfoo.c foo.nw | cpif foo.c
@end example

Then, if @file{foo.c} has not changed, it is not updated.
This is most useful in @file{Makefile} rules, since it prevents
@command{make} from recompiling @file{foo.c} unnecessarily.

I would prefer a mechanism that doesn't require the user to
install (or me to write) a separate program such as @command{cpif}.
In addition, I would like it to be possible to take directory structure
into account, since modern large programs generally group different
components into different subdirectories.

To that end, I think it makes sense to define a @dfn{template}
that describes how to update a file using system-level (shell)
commands.  Then for each file, the author can specify how to
make the substitutions in the template in order to do the update.

We define a default template, with the option for the user
to override it.

The template is defined with @samp{@@file_update_recipe @r{@dots{}}
@@end file_update_recipe}, and each file supplies values to the
template with a line like this:

@example
@@file_update @var{file} @var{directory} @var{suffix}
@end example

@(jrtangle@) =
@<File update recipe handling@>
@

Let's start with the default template. Taking a page from
Autoconf's book, we use @samp{@@@var{param}@@} to
specify the parameters. The possible parameters have hard-coded
names: @code{DIR}, @code{FILE}, and @code{SUFFIX}.
Note the quoting of shell expansions in case (somehow) any of
the various names contain whitespace characters.

@<File update recipe handling@>=
BEGIN {
	# This condition should distinguish between the native and
	# MSYS (POSIX-ish) Gawk.  We rely on the fact that MSYS mounts
	# /tmp and sets $TEMP to point to it, but resets the value
	# back to the native C:/Foo/Bar value when invoking native
	# programs.
	if (ENVIRON["TEMP"] ~ /^[A-Z]:[\\\/]/) {
		# MS-Windows recipe
		Update_recipe = \
			"fc /B \"@DIR@\\@FILE@\" \"@DIR@\\@FILE@@SUFFIX@\" >nul 2>&1 || move /Y \"@DIR@\\@FILE@\" \"@DIR@\\@FILE@@SUFFIX@\" >nul"
	} else {
		# POSIX recipe
		Update_recipe = \
			"PATH=/bin:/usr/bin\n" \
			"export PATH\n" \
			"destname=\"@DIR@/@FILE@\"\n" \
			"outname=\"${destname}@SUFFIX@\"\n" \
			"if [ ! -f \"$destname\" ]\n" \
			"then\n" \
			"\tmv \"$outname\" \"$destname\"\n" \
			"elif cmp -s \"$outname\" \"$destname\" > /dev/null\n" \
			"then\n" \
			"\trm \"$outname\"\n" \
			"else\n" \
			"\tmv \"$outname\" \"$destname\"\n" \
			"fi\n"
	}
}
@

The user can override this template.
The collection code should look familiar by now:

@cindex @code{@@file_update_recipe} command, @command{jrtangle}
@<File update recipe handling@>=
/^@file_update_recipe[[:space:]]*$/,
			/^@end file_update_recipe[[:space:]]*$/ {
	if (/^@file_update_recipe[[:space:]]*$/) {
		# start of construct, save line number, skip this line
		if ("file_update_recipe" in Line_numbers)
			fatal(_"cannot nest one @file_update_recipe inside another\n")
		Line_numbers["file_update_recipe"] = (FILENAME ":" FNR)
		Update_recipe = ""
	} else if (/^@end file_update_recipe[[:space:]]*$/) {
		# end of construct, delete line number, skip this line
		delete Line_numbers["file_update_recipe"]
	} else
		Update_recipe = Update_recipe "\n" $0

	next
}
@

Next we have to handle the definitions provided by the user. Well, actually,
this brings up the fact that we need defaults in case the user doesn't
provide values.  At this point, @command{gawk}'s true multidimensional arrays
add some nice clarity to what's going on:

@<File update recipe handling@>=
BEGIN {
	# @default is an unlikely name for a real file
	Update_value["@default"]["DIR"] = "."	# current directory
	Update_value["@default"]["SUFFIX"] = ".tangle_tmp"	# unlikely suffix
	# No default for filename, jrtangle knows it!
}
@

Note that it is is a bad idea to the shell's @code{$$} variable
for any of these values since the string returned to @command{gawk}
for the destination file will not have it expanded!@footnote{Here too,
guess how I found this out.}  If you really want something like
that, it could be done by changing this code to use @command{gawk}'s
@code{PROCINFO["pid"]}.

And @emph{now} we can deal with the user's values:

@cindex @code{@@file_update} command, @command{jrtangle}
@<File update recipe handling@>=
/^@file_update[[:space:]]/ {
	if (NF != 4)
		fatal(_"usage: @file_update name dir suffix\n")

	if ($4 == "\"\"")
		$4 = ""
	Update_value[$2]["DIR"] = $3
	Update_value[$2]["SUFFIX"] = $4

	next
}
@

The user can supply an explict empty string for the suffix.

Finally, we have to deal with creating the per-file template
string and the name of the destination file (a temporary one)
in which to place the output.
This function is called in @ref{Expanding code chunks}.

@findex @code{create_update_recipe()} function, @command{jrtangle}
@<File update recipe handling@>=
# create_update_recipe --- create update recipe per file,
#							return dest filename

function create_update_recipe(file, results,
							source_file, dir, suffix, recipe) # locals
{
	if (file in Update_value)
		source_file = file
	else
		source_file = "@default"

	dir = Update_value[source_file]["DIR"]
	suffix = Update_value[source_file]["SUFFIX"]

	delete results

	recipe = Update_recipe
	gsub(/@DIR@/, dir, recipe)
	gsub(/@FILE@/, file, recipe)
	gsub(/@SUFFIX@/, suffix, recipe)

	results["recipe"] = recipe
	results["output"] = (dir "/" file suffix)
}
@

Later on, the recipe is prefixed with the value of @code{Shell_debug},
which turns on execution tracing for shell commands.  (@code{Shell_debug}
is used in a few other places as well.)

@node jrtangle shell debug
@section Debugging Shell Commands Run By @command{jrtangle}

@code{Shell_debug}'s value is set based on the @code{Debug} variable. We
rely on the fact that @command{awk} variables are initialized to the empty
string.  However, if the user has provided a value (via @command{gawk}'s
@option{-v} option) we don't change it.  This is useful in non-POSIX
environments, for example.

@(jrtangle@) =
BEGIN {
	if (Debug ~ /shell/ && ENVIRON["TEMP"] !~ /^[A-Z]:[\\\/]/)
		if (length(Shell_debug) == 0)
			Shell_debug = "set -x; "
}
@

@node jrtangle after creation
@section Doing Something After Creating A File

A useful feature is to have the ability to do something to a file after it's
been created.  For example, to make a script file executable.

@(jrtangle@) =
@<Post Creation Tasks@>
@

The way to do this is to specify a line like the following:

@example
@@post_create @var{filename} @var{command to run}
@end example

The @var{command to run} is associated with @var{filename} and run after
the file is created.

@<Post Creation Tasks@>=
/^@post_create[[:space:]]+/ {
	if (NF < 3)
		fatal(_"usage: @post_create filename command\n")
	check_unfinished()

	name = $2
	$1 = $2 = ""
	$0 = $0
	Post_create_commands[name] = $0
}
@

And when dumping files, we run the associated command:

@<Run ``post create'' commands@> =
# run any "post create" command (such as changing mode)
if (i in Post_create_commands)
	system(Shell_debug Post_create_commands[i])
@

@node Common Chunks
@section Common Code Chunks and Functions

This section contains code chunks and @command{awk}
functions that are needed in both @command{jrtangle}
and @command{jrweave}.

@use_smallexample
@<GPL 3 Copyright statement@>=
#
# Copyright (C) 2013, 2014, 2015, 2016, 2019 Arnold David Robbins
# 
# This file is part of TexiWeb Jr., a literate programming system.
# 
# TexiWeb Jr. is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# TexiWeb Jr. is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
@
@use_example

Per suggestion from Karl Berry, we include a pointer to the web location
for current TexiWeb Jr.@: sources in both programs.

@<Source Code Repository Web Info@>=
#
# Up-to-date source code for TexiWeb Jr. can be obtained via
# Git from github:
#
#	git clone http://github.com/arnoldrobbins/texiwebjr
#
# This is Edition @value{EDITION}, last updated @value{UPDATE-MONTH}.
@

We need the following functions in both programs:

@table @code
@item message()
Print a message to standard error.
This function automatically adds @code{FILENAME} and @code{FNR} to the
message so that the user can tell where the problem is.
The first argument, @code{msg}, indicates what kind of message
is being printed (warning or fatal).

@item fatal()
Print an error message using @code{message()} and then exit.

@item warning()
Print a warning message using @code{message()} but don't exit.

@item join()
Join an array into a single string. This function is copied from
@uref{http://www.gnu.org/software/gawk/manual/html_node/Join-Function.html,
@cite{GAWK: Effective AWK Programming}},
(the @command{gawk}
documentation).

@end table

Since @command{gawk} does not have a ``varargs'' facility,
we simply supply 10 arguments; the extras are ignored if the
format string does not reference them.

@findex @code{message()} function
@findex @code{fatal()} function
@findex @code{warning()} function
@findex @code{join()} function
@<Helper Functions@>=
# Helper functions

# message --- write a particular kind of message out to stderr

function message(msg, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
{
	printf("%s:%d: %s: " format, FILENAME, FNR, msg,
		a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) > "/dev/stderr"

	if (substr(format, length(format), 1) != "\n")
		printf("\n") > "/dev/stderr"
}

# fatal --- print a fatal error message and exit.
#	 No varargs, so fake it with lots of parameters.

function fatal(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
{
	message(_"fatal", format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
	exit 1
}

# warning --- print a warning message to stderr
#	 No varargs, so fake it with lots of parameters.

function warning(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
{
	message(_"warning", format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
}

# join.awk --- join an array into a string
#
# Arnold Robbins, arnold@skeeve.com, Public Domain
# May 1993

function join(array, start, end, sep,    result, i)
{
	if (sep == "")
		sep = " "
	else if (sep == SUBSEP) # magic value
		sep = ""
	result = array[start]
	for (i = start + 1; i <= end; i++)
		result = result sep array[i]
	return result
}
@

We have a need for at least one debugging helper
function.

@(jrtangle@) =
@<Expansion debugging functions@>
@

The @code{dump_chunks()} function may be called if debugging.
Although this is something of a ``helper'' function, as it's
specific to @command{jrtangle}, it should not be included in
the same chunk with the other functions in this @value{SECTION}.

@findex @code{dump_chunks()} function, @command{jrtangle}
@<Expansion debugging functions@> =
# dump_chunks --- print out all the chunks

function dump_chunks(	i, format)
{
	format = "@<%s"
	format = format "@>=\n%s@\n\n"
	for (i in Code_contents)
		printf(format, i, Code_contents[i]) > "/dev/stderr"
}
@

@node jrweave code
@chapter Weaving: The @command{jrweave} Program

Weaving a @value{TWJR} document is in fact the more challenging task.
We want the output to look good, and we want to keep track of
where chunks are defined and referenced. In addition, we
have to remove any lines that are just for @command{jrtangle},
since Texinfo won't know what to do with them.

@menu
* jrweave two passes::           Two pass design.
* jrweave initial code::         Initial Stuff and Printing A Warning.
* jrweave handle ignore::        Handling @code{@@ignore} lines.
* jrweave ifweave iftangle::     Text inclusion/exclusion for
                                 @command{jrweave}.
* jrweave delete jrtangle code:: Removing stuff for @command{jrtangle}.
* jrweave choosing code size::   Choosing the code size.
* jrweave language additions::   Extra stuff for authors.
* jrweave chunk indexes::        Create indices for chunk definition and
                                 references.
* jrweave def/use collecting::   Collecting definition and use information.
* jrweave file chunks::          Processing file chunks.
* jrweave code chunks::          Processing code chunks.
* jrweave file defs::            Printing file definitions.
* jrweave code defs and refs::   Printing code definitions and references.
* jrweave print setup recipe::   Printing the initial setup recipe.
* jrweave last bit::             Passing everything else through.
* jrweave expanding tabs::       Expanding tabs.
* jrweave helper functions::     Helper functions for @command{jrweave}.
@end menu

@node jrweave two passes
@section Processing In Two Passes

The general tradition in literate programming documentation is that each
unique chunk is numbered sequentially from 1, in the order that they are
defined.  Even as chunks are added on to, they are referred to by the
same number.  The numbering is managed by the weaving process; the author
of a literate program does not have to do it.

An important part of the literate style is that a code chunk may be
referenced before it is defined; in fact this is usually the case.
This raises a difficulty; @command{jrweave} cannot print a chunk
with its associated number if it hasn't yet seen its definition.

@cindex Brennan, Michael
It is also traditional, for each chunk, to print a list of other
places where the chunk is defined, and where the chunk is used.
Mike Brennan suggests that furthermore, it is worthwhile to print
a list of sites where the chunks referenced by the current chunk
are defined.

The way to accomplish all this is to use a two-pass design. In the
first pass @command{jrweave} collects information about each
unique file chunk and each unique code chunk, assigning numbers as it
goes.  In the second pass it prints the file, formatting file
and code chunk names appropriately, and writing out the various
cross references.

Things are complicated somewhat by the fact
that Texinfo only gives us anchors and cross references, without
access to just the pages numbers where something occurs.
So, we'll do our best.

We start with the @samp{#!} header and the copyright statement,
and then proceed to arrange to perform two passes over the input.

@post_create jrweave chmod +x jrweave
@(jrweave@) =
@<Shebang header@>
@<Common Chunks@>
@<Set up two passes@>
@<Pass 2 debugging@>
@

We use the standard two-pass mechanism for an @command{awk}
program, which is to insert a variable assignment into
@code{ARGV} and to duplicate the list of input files in
additional elements in @code{ARGV}.
In order to allow very large documents which are split into multiple
files, we copy the full list over.

@<Set up two passes@> =
BEGIN {
	if (ARGC < 2)
		fatal(_"usage: jrweave file.twjr [...]\n")

	Pass = 1
	n = ARGC
	ARGV[ARGC++] = "Pass=2"
	for (i = 1; i < n; i++) {
		@<Disallow standard input for @command{jrweave}@>
		ARGV[ARGC++] = ARGV[i]
	}
}
@

Because of the two-pass nature of the code, we can't
accept standard input:

@<Disallow standard input for @command{jrweave}@> =
if (ARGV[i] == "-" || ARGV[i] == "/dev/stdin")
	fatal(_"jrweave: standard input not allowed\n")
@

This rule serves as a place to set a breakpoint in the
@command{gawk} debugger for when we start the second pass
through each @value{TWJR} source file:

@<Pass 2 debugging@>=
Pass == 2 && FNR == 1 && Debug ~ /pass2/ {
	junk++
}
@

@node jrweave initial code
@section Printing A Warning

We print an initial header to remind the user @emph{not} to edit the
generated Texinfo file.

@(jrweave@) =
@<Create ``do not edit'' warning@>
@<Helper Functions@>
@

The generated Texinfo file should have a warning at the top
not to edit the file, since this is an easy mistake to
to make (having made it myself!).  We will make it a little
fancy, just for the fun of it.

Printing the header is independent of the two-pass nature of the program
and thus can be done from a @code{BEGIN} block.
We have to fudge this a bit, since we are not
listing all the input files, just the first one.

@findex @code{print_do_not_edit()} function, @command{jrweave}
@<Create ``do not edit'' warning@>=
BEGIN {
	print_do_not_edit(ARGV[1])
}

# print_do_not_edit --- create and print warning

function print_do_not_edit(filename,	i, pl, pr, l, s, t)
{
	@<Set warning text @code{s} and @code{t}, compute left and right padding @code{pl} and @code{pr}@>
	@<Print a line of percent signs@>

	# print the titles with their padding
	printf("%% %*s%s%*s %%\n", pl, " ", t, pr, " ")
	printf("%% %s %%\n", s)

	@<Print a line of percent signs@>
}
@

Just to be pretty we center the ``do not edit this file'' warning
in the output line. The length of the line in turn depends on the
length of the following line stating the name of the file from
which the Texinfo file was created.
If the length is odd, we have one more space on the right than
on the left.

@<Set warning text @code{s} and @code{t}, compute left and right padding @code{pl} and @code{pr}@> =
t = _"DO NOT EDIT THIS FILE!!!!"
if (ARGC > 4)	# more than one file
	s = sprintf(_"It was created by jrweave from `%s' (or maybe others).",
			filename)
else
	s = sprintf(_"It was created by jrweave from `%s'.", filename)

l = length(s)
pl = int((l - length(t)) / 2)	# padding on left side, integer division!
pr = l - (pl + length(t))		# padding on right side
if ((pl + pr + length(t)) < l)	# account for odd lengths
	pr++
@

Printing a line of percent signs similarly depends on the length
of the text. The @samp{+ 4} is for the space and percent sign on
each side of the text.

@<Print a line of percent signs@>=
for (i = 1; i <= l + 4; i++)
	printf("%%")
printf "\n"
@

@node jrweave handle ignore
@section Handling @code{@@ignore} Lines

@xref{jrtangle handle ignore} for why we need this.

@(jrweave@) =
@<Handle lines between @code{@@ignore} and @code{@@end ignore}@>
@

@node jrweave ifweave iftangle
@section Document Sections Exclusive to Weaving and Tangling

As in @ref{jrtangle ifweave iftangle}, we need to process
@samp{@@iftangle @r{@dots{}} @@end iftangle} and
@samp{@@ifweave @r{@dots{}} @@end ifweave}. However, we
must do the opposite here of what we did there.

@(jrweave@) =
@<Handle @code{ifweave} and @code{iftangle} for @code{jrweave}@>
@

And without a lot of fanfare, here is the code:

@vindex @code{Line_numbers} variable
@vindex variable, @code{Line_numbers}
@cindex @code{@@ifweave} command, @command{jrweave}
@cindex @code{@@iftangle} command, @command{jrweave}
@<Handle @code{ifweave} and @code{iftangle} for @code{jrweave}@>=
# iftangle lines should be removed

/^@iftangle[[:space:]]*$/, /^@end iftangle[[:space:]]*$/ {
	if (Pass == 1)
		next

	if ("ifweave" in Line_numbers)
		fatal(_"cannot nest @iftangle inside @ifweave\n")

	# start of construct, save line number
	if (/^@iftangle[[:space:]]*$/)
		Line_numbers["iftangle"] = (FILENAME ":" FNR)

	# end of construct, delete line number
	if (/^@end iftangle[[:space:]]*$/)
		delete Line_numbers["iftangle"]

	# simply skip these lines, this is weaving
	next
}

# For weaving we remove the bracketing control lines and let anything
# in between fall through.

/^@ifweave[[:space:]]*$/, /^@end ifweave[[:space:]]*$/ {
	if (Pass == 1)
		next

	if ("iftangle" in Line_numbers)
		fatal(_"cannot nest @ifweave inside @iftangle\n")

	# start of construct, save line number, skip this line
	if (/^@ifweave[[:space:]]*$/) {
		Line_numbers["ifweave"] = (FILENAME ":" FNR)
		next
	}

	# end of construct, delete line number, skip this line
	if (/^@end ifweave[[:space:]]*$/) {
		delete Line_numbers["ifweave"]
		next
	}

	# otherwise fall through into the rest of the code
}
@

@node jrweave delete jrtangle code
@section Removing Stuff For @command{jrtangle}

As with any literate programming system, some commands are only for
tangling, and others are only for weaving.  Although the tangle component
only has to pull out source files and expand code, the weaving
component has to also recognize commands for the tangling component,
in order to keep them out of the document formatter's way.

@(jrweave@) =
@<Remove @code{jrtangle} commands for weaving@>
@

There are only three such commands, and all we have to
do is skip over them with @code{next}.

@cindex @code{@@file_update_recipe} command, @command{jrweave}
@cindex @code{@@file_update} command, @command{jrweave}
@cindex @code{@@post_create} command, @command{jrweave}
@<Remove @code{jrtangle} commands for weaving@> =
/^@file_update_recipe[[:space:]]*$/,
		/^@end file_update_recipe[[:space:]]*$/ {
	next
}
/^@file_update[[:space:]]/ {
	next
}
/^@post_create[[:space:]]+/ {
	next
}
@

The last two could be combined, but it's not really that big a deal.

@node jrweave choosing code size
@section Choosing The Code Size

Sometimes, code is just too wide for Texinfo's @code{@@example}
sections and it is better to use @code{@@smallexample}.  The
@code{@@use_smallexample} statement causes @command{jrweave}
to use @code{@@smallexample} for all the file and code chunks.

After some experimentation, it makes the most sense to make this
be dynamic, allowing a document author to switch things back
and forth.  To that end there is also a @code{@@use_example}
statement.

@(jrweave@) =
@<Switch example environment@>
@

A @code{BEGIN} block sets the default:

@<Switch example environment@> =
BEGIN {
	Example_start = "@example"
	Example_end = "@end example"
}
@

And then we can switch sizes at will:

@cindex @code{@@use_example} command, @command{jrweave}
@cindex @code{@@use_smallexample} command, @command{jrweave}
@<Switch example environment@> =
Pass == 2 && /^@use_smallexample[[:space:]]*$/ {
	Example_start = "@smallexample"
	Example_end = "@end smallexample"
	next
}

Pass == 2 && /^@use_example[[:space:]]*$/ {
	Example_start = "@example"
	Example_end = "@end example"
	next
}
@

@noindent
We then use @code{Example_start} and @code{Example_end} throughout the
rest of the program.

@node jrweave language additions
@section Additions For Writing Documents

Here are some additions to the Texinfo language that
ease both the formatting job and some of the authoring
work.

@menu
* jrweave additional macros::      Macros for writing documents.
* jrweave turning on xref titles:: Turning on titles in xrefs.
* jrweave sidebars::               Providing sidebars.
* jrweave @TeX{} control::         Additional features for @TeX{}.
@end menu

@node jrweave additional macros
@subsection Macros for Writing Documents

The first addition are some macros.
We add them to the output right before the title page.
This is so that the @code{@@EMAIL@{@}} macro can be used
on the copyright page without problems.

@(jrweave@) =
@<Texinfo authoring additions@>
@

@<Texinfo authoring additions@>=
Pass == 2 && /^@titlepage/ {
	@<Turn On Automatic Titles In Cross References@>
	print ""
	print "@c Start extra commands added by jrweave\n"
	@<Macro to hide email addresses in HTML@>
	print ""
	@<Macro for ``FIXME'' notes@>
	print ""
	@<Macro for ``old style'' numbers@>
	print "\n@c End extra commands added by jrweave"

	print ""
	print	# print the line

	next
}
@

Turning on automatic use of full titles in cross references is
discussed in @ref{jrweave turning on xref titles}.

For HTML output, we want to be able to provide an email address
as something like ``arnold AT skeeve.com'' in order to avoid
address harvesters and receiving even more spam. To that end
the document can use @samp{@@EMAIL@{arnold@@@@skeeve.com, arnold AT skeeve.com@}}
and things will happen the way we want them to.

@cindex @code{@@EMAIL} macro, @command{jrweave}
@cindex macro, @command{jweave}, @code{@@EMAIL}
@<Macro to hide email addresses in HTML@>=
print "@c For HTML, spell out email addresses, to avoid problems with"
print "@c address harvesters for spammers."
print "@ifhtml"
print "@macro EMAIL{real,spelled}"
print "``\\spelled\\''"
print "@end macro"
print "@end ifhtml"
print "@ifnothtml"
print "@macro EMAIL{real,spelled}"
print "@email{\\real\\}"
print "@end macro"
print "@end ifnothtml"
@

Next is a simple macro to add little ``FIXME'' notes throughout the
manuscript.  It often happens when writing one thing that I think of
something else that needs more work, but I don't want to detour to that
second thing at the moment. This way I can leave myself a note
that will appear in the output so that I will remember to tend to it.
(They should all be fixed by the time everything is done.)

@cindex @code{@@FIXME} macro, @command{jrweave}
@cindex macro, @command{jweave}, @code{@@FIXME}
@<Macro for ``FIXME'' notes@>=
print "@macro FIXME{text}"
print "@strong{FIXME}: \\text\\"
print "@end macro"
@

Finally, we want to use @TeX{}'s ``old style'' numbers for
numbering the code chunks.
Following advice from Karl Berry, we define the macro unconditionally
and then redefine it just for @TeX{}.  This lets @file{texinfo.tex} be
smarter about how it puts chunk names into the indexing.
The unconditional macro will take effect
in the other formats; the result will be just the number itself.

@cindex @code{@@oldnum} macro, @command{jrweave}
@cindex macro, @command{jweave}, @code{@@oldnum}
@<Macro for ``old style'' numbers@>=
print "@macro oldnum{value}"
print "\\value\\"
print "@end macro"
print ""
print "@tex"
print "\\gdef\\oldnum#1{\\begingroup\\oldstyle #1\\endgroup}%"
print "@end tex"
@

After some experimentation and thought, I've decided to make
the default be that chunks are unnumbered.
However, as
a matter of taste, it may be that an author decides
to have numbers in the printed chunk names.  This can
be done using the @code{@@numberedchunks} command.
This can be placed anywhere in the document; by checking for
it during the first pass we guarantee it will be in effect
when the document is output.
The variable @code{Numbered_chunks} is then checked during
chunk name formatting.
The check for the first pass is inside the body of the rule
since the command must be removed from the output
during the second pass.

@<Texinfo authoring additions@>=
/^@numberedchunks[[:space:]]*$/ {
	if (Pass == 1)
		Numbered_chunks = TRUE
	next
}
@

@cindex @code{@@file_chunk_full_defs} command, @command{jrweave}
Also after some experimentation, I found that printing the
full list of definition points for file chunks after each
occurrence wasn't very helpful.  There can be many such,
and the list mostly just takes up space.  However, if
an author wants this list, it can be printed with the
@code{@@file_chunk_full_defs} command.

@<Texinfo authoring additions@>=
/^@file_chunk_full_defs[[:space:]]*$/ {
	if (Pass == 1)
		Print_file_full_defs = TRUE
	next
}
@

@node jrweave turning on xref titles
@subsection Turning On Titles in Cross References

For cross references to anchors to appear properly in the output
of @TeX{}, we need to let @file{texinfo.tex} supply the full titles
instead of the node/anchor names.

Although this isn't really an authoring extension, it's invoked
from that part of the code since that is the right place to insert
this statement.

@<Turn On Automatic Titles In Cross References@>=
print "@c Let texinfo.tex give us full section titles"
print "@xrefautomaticsectiontitle on"
@

@node jrweave sidebars
@subsection Providing Sidebars

Sidebars are blocks of text with a title that are set off to the side in
a printed book (or magazine). They address topics of tangential interest
that are worth discussing but not necessarily part of the main flow of
a section.  Since Texinfo doesn't support them, and I want to be able
to have them, this code provides them. It collects the title and text,
and outputs them twice, once for DocBook, and once for everything
else using Texinfo's @code{@@cartouche} environment.
The title is provided on the opening @code{@@sidebar} line.

@cindex @code{@@sidebar} command, @command{jrweave}
@<Texinfo authoring additions@>=
Pass == 2 && /^@sidebar[[:space:]]+/ {
	sub(/^@sidebar[[:space:]]+/, "", $0)
	Sidebar_title = $0
	Sidebar_body = ""
	Collecting_sidebar = TRUE
	next
}

Pass == 2 && /^@end[[:space:]]+sidebar[[:space:]]*$/ {
	Collecting_sidebar = FALSE
	printf "@cindex sidebar, %s\n", Sidebar_title
	printf "@ifdocbook\n"
		printf "@docbook\n"
		printf "<sidebar><title>%s</title>\n", Sidebar_title
		printf "@end docbook\n"
			print Sidebar_body
		print ""
		printf "@docbook\n"
		printf "</sidebar>\n"
		printf "@end docbook\n"
	printf "@end ifdocbook\n\n"

	printf "@ifnotdocbook\n"
		printf "@cartouche\n"
		printf "@center @b{%s}\n\n", Sidebar_title
			print "@noindent"
			sub(/^\n*/, "", Sidebar_body)	# remove initial newlines
			print Sidebar_body
		printf "@end cartouche\n"
	printf "@end ifnotdocbook\n"
	Sidebar_body = ""
	next
}

Pass == 2 && Collecting_sidebar {
	Sidebar_body = Sidebar_body "\n" $0
	next
}
@

@sidebar Test Sidebar
This is a test sidebar, just to show what one looks like,
and to make sure that the @command{jrweave} code works.

And here is a second paragraph, to show that (in Texinfo) the first
paragraph of a sidebar is not indented, whereas subsequent ones are.
@end sidebar

@node jrweave @TeX{} control
@subsection Additional Features for @TeX{}

There are some additional changes that make the output from @TeX{}
a little bit nicer.  We'll explain them as we go along.

@quotation CAUTION
All of the features in the @value{SUBSECTION} depend upon the
macros in @file{texinfo.tex}.  If they change in an incompatible way,
these features may break or become impossible to continue to maintain.
Use them with care!
@end quotation

@<Texinfo authoring additions@>=
@<Change cross-reference quoting@>
@<Change PDF internal link color@>
@<Set URL formatting@>
@<Enable braces in index entries@>
@

@menu
* Cross-reference quoting::     Changing quoting for cross-references.
* PDF links::                   Changing the color of internal PDF links.
* URL formatting::              Link color and text formatting for URLs.
* Improved index entries::      Creating improved index entries.
@end menu

@node Cross-reference quoting
@subsubsection Changing Quoting for Cross-References

I happen to dislike the way chapter and section titles are quoted in
cross-references in @TeX{} output.  You can change to use double-quoted
titles with the @code{@@dquotexrefs} command:

@<Change cross-reference quoting@> =
Pass == 2 && /^@dquotexrefs[[:space:]]*$/ {
	print "@tex"
#	print "%\\gdef\\xrefprintnodename#1{{\\it #1}}"
	print "\\gdef\\xrefprintnodename#1{``#1''}"
	print "@end tex"

	next
}
@

@noindent
The commented-out @code{print} statement shows an alternative that I
experimented with, to italicize titles, but then the formatting doesn't
look quite as good.

@node PDF links
@subsubsection Changing The Color of Internal PDF Links

Texinfo is slightly schizophrenic in relation to output from @TeX{}.
In particular, PDF provides the ability to have @dfn{links}, both
within the document and to external URLs.  In a PDF viewer, clicking
on an internal link takes you to the target, whereas clicking on a URL
starts a web browser.  Previously, when a Texinfo file was processed with
pdf@TeX{}, both cross-references and URLs were formatted as PDF links,
in a different color.

On the other hand, regular DVI output is intended more for printing.  Thus,
when run with regular @TeX{}, Texinfo documents showed URLs inline in
the text, and cross references were printed in black.

It is important to note that PDF files can also be used as the master
for printing.  In such a case, you @emph{don't} want cross-references
in a different color and you @emph{do} want URLs to appear in the text.

Because of this confusion, in November 2013, @file{texinfo.tex} was changed to use
the DVI printing style for both cross-references and URLs. However,
facilities were documented for enabling the previous behavior should
you wish to do so.

The following set of new commands makes it easy to enable these
features if you wish. The first one is:

@example
@@pdflinkcolor @r{[} @var{red green blue} @r{]}
@end example

This sets the color for internal links.  Here, @var{red}, @var{green}
and @var{blue} are values between zero and one (inclusive) to indicate
how much of each color to use in creating the final color.
The default is the previous value used by @file{texinfo.tex},
called ``dark red:'' 0.50 red, 0.09 green, and 0.12 blue.

@(jrweave@) =
BEGIN {
	Dark_red = "0.5 0.09 0.12"
}
@

@<Change PDF internal link color@> =
Pass == 2 && /^@pdflinkcolor[[:space:]]*.*$/ {
	if (NF != 1 && NF != 4)
		fatal(_"@pdflinkcolor: wrong number of arguments\n")

	if (NF == 1)
		Link_color = Dark_red
	else {
		$1 = ""
		$0 = $0
		Link_color = $0
	}

	print "@tex"
	print "\\gdef\\linkcolor{" Link_color "}"
	print "@end tex"

	next
}
@

@node URL formatting
@subsubsection Link Color And Text Formatting For URLs

Similar to internal links, you can set the color of URL links.
They are independent of each other. The command here is @code{@@urllinkcolor}
(and the default color is the same):

@<Set URL formatting@> =
Pass == 2 && /^@urllinkcolor[[:space:]]*.*$/ {
	if (NF != 1 && NF != 4)
		fatal(_"@urllinkcolor: wrong number of arguments\n")

	if (NF == 1)
		URL_color = Dark_red
	else {
		$1 = ""
		$0 = $0
		URL_color = $0
	}

	print "@tex"
	print "\\gdef\\urlcolor{" URL_color "}"
	print "@end tex"

	next
}
@

Besides setting the color for URLs, you can control whether the text of
a URL should appear in the document text, or not. By default, it does
appear.  To make it disappear, use @code{@@hideurls}:

@<Set URL formatting@> =
Pass == 2 && /^@hideurls[[:space:]]*$/ {
	print "@tex"
	print "\\global\\urefurlonlylinktrue"	# NOTE: *not* \gdef
	print "@end tex"

	next
}
@

@node Improved index entries
@subsubsection Creating Improved Index Entries

Until Texinfo 5.2, if open or close braces were the first real character
in an index entry, they were indexed under @samp{|}, which comes between
the brace characters in ASCII order.  This was largely due to how the
@command{texindex} program worked; it required balanced braces in the
input created for it by @file{texinfo.tex}.

Early in 2014 I fixed this by rewriting @command{texindex} in
@command{awk} (using @value{TWJR} to do so!) and current versions of
@file{texinfo.tex} allow enabling index entries where braces may be used.
The @value{TWJR} command @code{@@allowindexbraces} enables this feature.

@<Enable braces in index entries@> =
Pass == 2 && /^@allowindexbraces[[:space:]]*$/ {
	print "@tex"
	print "\\global\\usebracesinindexestrue"	# NOTE: *not* \gdef
	print "@end tex"

	next
}
@

As of at least April, 2019, and I think a bit earlier, the above
command is neither necessary, nor accepted by @file{texinfo.tex};
use it only on versions where it's needed.

@node jrweave chunk indexes
@section Creating Indices For Chunks

@ignore
Besides printing out the list of file definitions and code chunk
definitions and references (@pxref{jrweave file defs}, and
@pxref{jrweave code defs and refs}),
@end ignore
@command{jrweave} creates index entries for
each chunk's definition(s) and use(s).  This provides
@ignore
another
@end ignore
an easy way
way to
find information, based on alphabetic lookup of a chunk name.

The index names are @samp{cd} for ``chunk definition'' and
@samp{cr} for ``chunk reference.''
(This follows Texinfo convention of using two-letter index names.)
It is up to the author of a document to either print the indices
using a regular Texinfo @code{@@printindex} command or to merge
them into one of the standard Texinfo indices, such as the
concept index, @samp{cp}. For @value{TWJR},  I have taken
the latter course. Towards the front of this @value{DOCUMENT} I have:

@example
@@synindex cd cp
@@synindex cr cp
@end example

@(jrweave@) =
@<Create Chunk Indices@>
@

According to the Texinfo manual, new indices should be created right
after the Texinfo header.

@<Create Chunk Indices@> =
Pass == 2 && /^@c %\*\*end of header/ {
	print	# print the line

	print "\n@c Extra indices added by jrweave"
	print "@defindex cd   @c chunk definition"
	print "@defindex cr   @c chunk reference"

	next
}
@

@node jrweave def/use collecting
@section Tracking Definitions and Uses

@cindex Brennan, Michael
@quotation
A literate document defines a directed acyclic graph of code chunks.
Mostly it is a tree.

A chunk's parents are where it is used.  If all chunks were only used
in one place, it would be a tree.

It's children are chunks it uses.
Chunks added onto it are siblings.

For the document to be useful for understanding, using and maintaining
the code, the reader needs to be able to easily traverse this graph.
@author Michael Brennan
@end quotation

As mentioned at the beginning of this @value{CHAPTER}, at the place
where a chunk is defined (or added on to) we want to
be able to present to the reader the following:

@itemize @bullet
@item
A list of the other places where it is defined.

@item
A list of places where the chunk is used (the chunks that call this one).

@item
The definition points for any chunks it references.
@end itemize

Let's define this more formally.
Everything will live in an array named @code{Chunk_info}, whose top
level index is the chunk name.
The name of the current chunk will be @code{Current_chunk}.

@quotation NOTE
In all cases, we store and use the name of a chunk without the leading
and trailing delimiters.
@end quotation

We need to track the following:

@table @asis
@item Chunk type (@code{Chunk_info[Current_chunk]["type"]})
File chunk or code chunk.
The value is either @code{"file chunk"} or @code{"code chunk"}.
By default, we assume that the list of file chunk definitions provide
by @code{@@print_file_defs} (@pxref{jrweave file defs}) is adequate,
and that Mike's graph of chunks relates mainly to code chunks.
Should an author wish to have the full list of file definitions at each
point in the document where a file chunk is defined, he may use the
@code{@@file_chunk_full_defs} command (@pxref{jrweave additional macros}).

@item Chunk number (@code{Chunk_info[Current_chunk]["chunk number"]})
This is mainly for tradition; in @value{TWJR} chunk numbers
don't bring any real added value.@footnote{Mike's @command{mweb} numbers chunks with
page number and occurrence on the page. E.g., chunk ``3b'' is the second chunk
on page 3.  I can't do that without @emph{a lot} of grubbing around with
raw @TeX{}, which I don't know how, nor want, to do.  And even if I were to bother,
that would not solve the problem for other formats such as DocBook or HTML.}
Thus, the default is not to have numbers, bu they can be enabled
with the @code{@@numberedchunks} command
(@pxref{jrweave additional macros}).

@item Definition points (@code{Chunk_info[Current_chunk]["defn"]})
Each point where a chunk is defined (created or added onto) is a definition point.
These are the siblings in Mike's graph.
It is enough to track how many definitions there are by incrementing
this array element. The definition number is used to generate Texinfo anchors
which are used in cross references.
All references to other chunks, and to sibling definitions of the current
chunk, will use cross references to anchors.

@item Second pass definition points (@code{Chunk_info[Current_chunk]["redefn"]})
This is similar to the @code{"defn"} element; it is needed on the second
pass to know where we are in the list of chunk definitions.

@item Referrers, or callers (@code{Chunk_info[Current_chunk]["callers"][@dots{}]})
We need a list of other chunks that refer to this one in their bodies.
This will be indexed by chunk name, and we will print the list
sorted by chunk name.
@end table

The list of chunks that the current chunk calls
must be collected during both passes.  During the first pass (code gathering), we update each
called chunk's ``callers'' list with the name of the current chunk, if it's not
already there.
During the second pass (code formatting), the list of called chunks
needs to be collected for printing cross reference information
at the end of the current chunk's definition.

All of the rest of the above information must be collected on the first pass through
the source document file(s).

@node jrweave file chunks
@section Processing File Chunks for @command{jrweave}

Now comes the hard part. We first collect the lines,
process the chunks during the first pass, and print them
in the second pass.

@menu
* jrweave chunk collection::       Collecting file and code chunks.
* jrweave file chunks processing:: Processing the file chunks.
* jrweave file chunks printing::   Printing the file chunks.
@end menu

@node jrweave chunk collection
@subsection Collecting File And Code Chunks

We use the same process for file chunks
and for code chunks, although each is tracked separately.

@(jrweave@) =
@<Process file chunks for @code{jrweave}@>
@<Process code chunks for @command{jrweave}@>
@

The initial code is similar to that of @command{jrtangle}.

@<Process file chunks for @code{jrweave}@>=
$0 ~ File_chunk_pattern {
	@<Common file chunk initial processing@>
	next
}
@

Checking for the terminating @samp{@@} sign must
come right after the two patterns that start collecting
lines.

@(jrweave@) =
@<Handle terminating at-sign for file and code chunks@>
@<Collect chunk lines@>
@

@node jrweave file chunks processing
@subsection Processing The Chunks

The @code{end_file_gathering()} function is where we will do all the work.
It simply delegates to two different functions based on whether we are
collecting data (pass 1) or printing it (pass 2).  In fact, the actions
are the same for file chunks and code chunk, so the work can be delegated
to a common function which makes the decision and does the work.

@(jrweave@) =
function end_chunk_gathering()
{
	if (Pass == 1) {
		collect_chunk_info()
		Chunk_lines = ""
		Flags[Chunk_type] = FALSE
	} else
		print_out_chunk()
}

function end_file_gathering()
{
	end_chunk_gathering()
}
@

If we do this right, everything we do here can be
reused for code chunks. First, let's collect all the
information we're going to need.

@(jrweave@)=
function collect_chunk_info(	i, n, x, called, junk)
{
	# Current_chunk, Chunk_type already set by initial code
	# Chunk number:
	if (! ("chunk number" in Chunk_info[Current_chunk])) {
		Chunk_info[Current_chunk]["chunk number"] = \
								++Chunk_numbers[Chunk_type]
	}

	# Definition instance
	Chunk_info[Current_chunk]["defn"]++

	# Get names of called chunks into called
	n = split(Chunk_lines, junk, Chunk_name_pattern, called)

	# Add ourselves to the callers
	for (i in called) {
		x = strip_out_name(called[i])
		Chunk_info[x]["callers"][Current_chunk] = TRUE
	}
}
@

@node jrweave file chunks printing
@subsection Printing The File Chunks

On the second pass, we print the chunk.

@(jrweave@)=
function print_out_chunk(	x, y, n, i, parts, names,
							name, anchor, chunk_being_used)
{
	# Redefinition instance
	Chunk_info[Current_chunk]["redefn"]++

	@<Print the chunk@>
}
@

Printing the chunk encompasses printing the leading stuff,
formatting the code lines for @TeX{}, such as expanding tabs,
formatting the names of the referenced chunks, and
closing off the environment.
Then we have to print all the cross reference information.

@<Print the chunk@> =
@<Try to keep at least the first two lines of the chunk together@>
@<Print the anchor@>
@<Convert the lines for @TeX{}@>
@<Format chunk names and reassemble output lines@>
@<Print the complete chunk@>
@<Print chunk cross reference information@>
@

@menu
* Keeping lines together::      Keeping chunk lines together.
* Formatting the anchor::       Formatting the anchor.
* Expanding tabs::              Expanding tabs.
* Printing the complete chunk:: Printing the complete chunk.
* Printing chunk cross references:: Printing chunk cross references.
@end menu

@node Keeping lines together
@subsubsection Keeping Chunk Lines Together

For aesthetic purposes, it would be good to keep at least the first
two lines of the chunk together.  The Texinfo command to do this
is @code{@@need}, which takes an argument in ``mils''---thousandths of
an inch.

So, how many thousandths of an inch do two lines take? Karl Berry advised
to try using @samp{@@showthe@@baselineskip}.  The result is 13.2 points.
There are 72 points in an inch, so one line is 13.2 divided by 72 = 0.183
inches.  Multiply that by two, and we get 0.367 inches.  We round that
up to a slightly larger number in the hopes that this will actually
work:@footnote{Unfortunately, this doesn't always work. I don't know why.}

@<Try to keep at least the first two lines of the chunk together@> =
print "@need 400"
@

@node Formatting the anchor
@subsubsection Formatting The Anchor

Formatting the anchor is handled by a separate function which we'll
see later. The output is the anchor.  Since we are in the second pass,
we have to pass it the @code{"redefn"} value for where we are, and the
@code{"defn"} value which represents the total number of definitions.

@<Print the anchor@> =
anchor = format_anchor(Current_chunk,
			Chunk_info[Current_chunk]["redefn"],
			Chunk_info[Current_chunk]["defn"])
printf("%s\n", anchor)
@

@node Expanding tabs
@subsubsection Expanding Tabs During Processing

Converting the lines means expanding the tabs, and then splitting the
total set of lines apart at each chunk name.  The regular text goes
into the array @code{parts}, and the chunk names into the array @code{names}.

@<Convert the lines for @TeX{}@> =
x = expand_tabs(Chunk_lines, Tabstop)
# extract code chunks
n = split(x, parts, Chunk_name_pattern, names)

# escape special chars in parts of code that aren't chunk names
for (i = 1; i in parts; i++)
	gsub(/[@{}]/, "@&", parts[i])
@

@<Format chunk names and reassemble output lines@> =
y = parts[1]
if (n > 1) {	# embedded chunk names
	for (i = 1; i in names; i++) {
		name = strip_out_name(names[i])
		chunk_being_used = \
			format_chunk_name(name, Chunk_info[name]["chunk number"],
				Chunk_info[name]["type"])
		printf("@crindex %s, use @sortas{%s, use}\n", chunk_being_used, remove_markup(name))
		y = y chunk_being_used
		y = y parts[i+1]
	}
}
@

By using @code{@@sortas} in the index entry, chunk names
are placed in the index under the heading of their initial
letter, instead of all ending up under @samp{<}.  (This might
be worth enhancing to be under user control.)
The @code{remove_markup()} function removes Texinfo markup,
which isn't allowed inside the argument to @code{@@sortas}.

@node Printing the complete chunk
@subsubsection Printing The Complete Chunk

We can now print the entire formatted chunk.

@<Print the complete chunk@> =
chunk_being_defined = \
	format_chunk_name(Current_chunk,
						Chunk_info[Current_chunk]["chunk number"],
						Chunk_type)
printf("@cdindex %s, definition @sortas{%s, definition}\n",
	chunk_being_defined, remove_markup(Current_chunk))
printf("@noindent\n%s %s@equiv{}\n",
	chunk_being_defined,
	Chunk_info[Current_chunk]["redefn"] == 1 ? "" : "+")
print Example_start
printf("%s\n", y)
print Example_end
@

@<Print chunk cross reference information@>=
for (i in names)
	names[i] = strip_out_name(names[i])	# remove delimiters

@<Move to a smaller font@>
# Print other definition sites for code chunks, or for file
# chunk if Print_file_full_defs is true
if (Chunk_type == "code chunk" || Print_file_full_defs) {
	@<Print list of other places where this chunk is defined@>
}
# Print callers for code chunks
if (Chunk_type == "code chunk") {
	@<Print list of chunks that call this one@>
}
@<Remove duplicates from @code{names}@>
@<Print list of called chunks@>
@<Move back to the regular font@>
@

@node Printing chunk cross references
@subsubsection Printing Chunk Cross References

After the chunk, we print the other places where it's defined.

@<Print list of other places where this chunk is defined@> =
print_other_defns(Current_chunk,
		Chunk_info[Current_chunk]["defn"],
		Chunk_info[Current_chunk]["redefn"])
@

@(jrweave@) =
function print_other_defns(chunk, total_defns, current_defn,
							other_defns, i, j)	# locals
{
		if (total_defns == 1)
			return

		print ""
		print "@noindent"
		print "This chunk is also defined in"

		for (i = j = 1; i <= total_defns; i++) {
			if (i == current_defn)
				continue

			other_defns[j++] = i
		}

		for (i = 1; i < j; i++) {
			printf("%s", format_xref(chunk, other_defns[i]))
			if (i + 2 == j)
				print ", and"
			else if (i + 2 < j)
				print ","
		}
		print "."
}
@

@<Print list of chunks that call this one@>=
if ("callers" in Chunk_info[Current_chunk]) {
	print ""
	asorti(Chunk_info[Current_chunk]["callers"], my_callers)
	if (length(my_callers) > 1) {
		print "@noindent"
		print "This chunk is called by the following chunks:\n"
		print_ref_table(my_callers)
	} else {
		n = Chunk_info[my_callers[1]]["defn"]

		print "@noindent"
		printf("This chunk is called by %s; see its first definition at %s.\n",
			format_chunk_name(my_callers[1],
						Chunk_info[my_callers[1]]["chunk number"],
						Chunk_info[my_callers[1]]["type"]),
			format_xref(my_callers[1], n > 1 ? 1 : 0))
	}
} else
	warning(_"chunk %s has no callers\n", Current_chunk)
@

The @code{print_ref_table()} function prints out a table
of chunk names and references to the first definition points.
The list of names has already had delimiters removed.

@(jrweave@) =
function print_ref_table(chunklist,		i, x, n)
{
	print "@multitable @columnfractions .35 .65"
	print "@headitem Chunk name @tab First definition point"

	for (i = 1; i in chunklist; i++) {
		x = chunklist[i]
		n = (Chunk_info[x]["defn"] > 1) ? 1 : 0
		printf("@item %s @tab See %s.\n",
			format_chunk_name(x,
				Chunk_info[x]["chunk number"],
				Chunk_info[x]["type"]),
			format_xref(x, n))
	}

	print "@end multitable"
}
@

@FIXME{Move the tests in the last parameter for format_xref into
the function itself.}

@<Print list of called chunks@> =
switch (length(names)) {
case 0:
	break
case 1:
	print "\n@noindent"
	printf("The called chunk %s is first defined at\n%s.\n",
			format_chunk_name(names[1],
						Chunk_info[names[1]]["chunk number"],
						Chunk_info[names[1]]["type"]),
						format_xref(names[1],
							(Chunk_info[names[1]]["defn"] > 1) ? 1 : 0))
	break;
default:
	print "\n@noindent"
	printf("The following table lists called chunk definition points.\n")
	print_ref_table(names)
	break;
}
@

@<Remove duplicates from @code{names}@>=
sort_and_remove_duplicates(names)
@

@(jrweave@) =
function sort_and_remove_duplicates(names,	i, dups)
{
	for (i in names)
		dups[names[i]] = 1

	asorti(dups)
	delete names
	for (i in dups)
		names[i] = dups[i]
}
@

The chunk cross reference information disrupts the flow
of the text, so (following literate programming tradition)
we print it in a smaller font. At the moment this only works
for @TeX{}. It might could be made to work for HTML, but
I'm not sure.
As with the macros in @ref{jrweave @TeX{} control}, this
depends on the innards of @file{texinfo.tex}. The
@code{@@smallfonts} puts the new, smaller fonts in place
and the @code{@@rm} (``Roman'') actually switches to them.

@<Move to a smaller font@>=
print "@iftex"
print "@smallfonts @rm"
print "@end iftex"
@

@<Move back to the regular font@>=
print "@iftex"
print "@textfonts @rm"
print "@end iftex"
@

@node jrweave code chunks
@section Processing Code Chunks for @command{jrweave}

Code chunk collection and formatting can now benefit from all
the work done previously.

@<Process code chunks for @command{jrweave}@> =
$0 ~ Code_chunk_pattern {
	@<Common code chunk initial processing@>
	next
}
@

@(jrweave@) =
function end_code_gathering()
{
	end_chunk_gathering()

	if (Debug ~ /code/)
		printf("finished formatting code %s\n",
					Code_chunk) > "/dev/stderr"
}
@

@node jrweave file defs
@section Printing File Definitions 

At this point we have collected and printed all the file and code
definition chunks. Along the way we have gathered information about where
each chunk is defined and where each chunk is referenced (used inside
a chunk body), and we printed the relevant parts of that information
after each chunk.

It is also useful to print centralized lists of everywhere that
file chunks and code chunks are defined.  This @value{SECTION} treats
file chunks.

@quotation NOTE
Since all the information is collected during the first pass, the lists
could be printed anywhere in the document. However the general intent
is that these lists be placed in an appendix at the end of the document,
which makes the nost sense anyway.
@end quotation

The command to print the file definitions is @code{@@print_file_defs}.

@(jrweave@) =
@<Handle @code{print_file_defs}@>
@

This is done in the second pass:

@cindex @code{@@print_file_defs} command, @command{jrweave}
@<Handle @code{print_file_defs}@> =
Pass == 2 && /^@print_file_defs[[:space:]]*$/ {
	@<Print file chunk definition list@>
	next
}
@

We first build a sorted array of file names,
and then print out the definitions in order.

@<Print file chunk definition list@> =
delete Sorted_file_names
j = 1
for (i in Chunk_info) {
	if (Chunk_info[i]["type"] == "file chunk")
		Sorted_file_names[j++] = i
}
asort(Sorted_file_names)	# Sorted by value
@

Next, we have to loop through the names and print out
the relevant info. We do it in a Texinfo @code{@@table}.

@<Print file chunk definition list@> =
print "@table @asis"
for (i = 1; i in Sorted_file_names; i++) {
	name = Sorted_file_names[i]
	@<Format and print chunk definition list@>
}
print "@end table"
@

@<Format and print chunk definition list@> =
x = format_chunk_name(name,
			Chunk_info[name]["chunk number"],
			Chunk_info[name]["type"])
printf("@item %s\n", x)
n = Chunk_info[name]["defn"]
if (n == 1) {
	printf("This chunk is defined in\n")
	printf("%s.\n", format_xref(name, 0))
} else {
	printf("Multiple definitions occur in\n")
	for (j = 1; j <= n; j++) {
		printf("%s", format_xref(name, j))
		if (j == n - 1)
			printf(",\nand\n")
		else if (j < n - 1)
			printf(",\n")
	}
	print ".\n"
}
@

@node jrweave code defs and refs
@section Printing Code Definitions and References

Unlike files, for code we want to print both
definitions and references.

@menu
* jrweave print code defs::     Printing code definitions.
* jrweave print code refs::     Printing code references.
@end menu

@node jrweave print code defs
@subsection Printing Code Definitions

Printing code definitions is almost identical to printing
file definitions.

@(jrweave@) =
@<Handle @code{print_code_defs}@>
@

This too is done in the second pass:

@cindex @code{@@print_code_defs} command, @command{jrweave}
@<Handle @code{print_code_defs}@> =
Pass == 2 && /^@print_code_defs[[:space:]]*$/ {
	@<Print code chunk definition list@>
	next
}
@

We first build a sorted array of code chunk names,
and then print out the definitions in order.

@<Print code chunk definition list@> =
@<Create @code{Sorted_code_names}@>
@

Creating the array of sorted code chunk names is also
done when printing code chunk references, so it lives in
its own chunk.

@<Create @code{Sorted_code_names}@> =
delete Sorted_code_names
j = 1
for (i in Chunk_info) {
	if (Chunk_info[i]["type"] == "code chunk")
		Sorted_code_names[j++] = i
}
asort(Sorted_code_names)	# Sorted by value
@

Next, we have to loop through the names and print out
the relevant info. We do it in a Texinfo @code{@@table}.

@<Print code chunk definition list@> =
print "@table @asis"
for (i = 1; i in Sorted_code_names; i++) {
	name = Sorted_code_names[i]
	@<Format and print chunk definition list@>
}
print "@end table"
@

@node jrweave print code refs
@subsection  Printing Code References

Printing code references is the flip side of printing code definitions.

@(jrweave@) =
@<Handle @code{print_code_refs}@>
@

First, recognize the @code{@@print_code_refs} command:

@cindex @code{@@print_code_refs} command, @command{jrweave}
@<Handle @code{print_code_refs}@> =
Pass == 2 && /^@print_code_refs[[:space:]]*$/ {
	@<Create @code{Sorted_code_names}@>
	@<Print code chunk references list@>
	next
}
@

We start by pretending that we have the information we need,
and printing it out.

@<Print code chunk references list@> =
print "@table @asis"
for (i = 1; i in Sorted_code_names; i++) {
	name = Sorted_code_names[i]

	n = Chunk_info[name]["defn"]
	if (n == 0)		# warning printed elsewhere
		continue

	fmt_name = format_chunk_name(name, Chunk_info[name]["chunk number"],
							Chunk_info[name]["type"])
	printf("@item %s\n", fmt_name)

	Current_chunk = name	# for use by next chunk
	@<Print list of chunks that call this one@>
}
print "@end table"
@

@node jrweave print setup recipe
@section Printing The Initial Setup Recipe

It may be that an author wants to include the initial setup
in the printed document.  To do so, place
@samp{@@print_initial_setup @r{[}@var{chunkname}@r{]}}
into the @value{TWJR} document on a line by itself.
If no @var{chunkname} is provided, then the chunk is
named ``Initial setup.''

@(jrweave@) =
@<Handle the initial setup chunk for @code{jrweave}@>
@

@cindex @code{@@print_initial_setup} command, @command{jrweave}
@cindex @code{@@initial_setup} command, @command{jrweave}
@<Handle the initial setup chunk for @code{jrweave}@> =
/^@print_initial_setup([[:space:]]+.*|[[:space:]]*)$/ {
	Print_initial_setup = TRUE
	if (NF > 1) {
		$1 = ""
		$0 = $0
		Initial_setup_name = $0
	}
	else
		Initial_setup_name = "Initial setup"

	next
}

/^@initial_setup[[:space:]]*$/, /^@end initial_setup[[:space:]]*$/ {
	if (Pass == 1 || ! Print_initial_setup)
		next

	Chunk_info[Initial_setup_name]["type"] = "code chunk"
	Chunk_info[Initial_setup_name]["defn"] = 1
	if (/^@initial_setup[[:space:]]*$/) {
		@<Try to keep at least the first two lines of the chunk together@>
		printf("%s\n", format_anchor(Initial_setup_name, 0))
		printf("@noindent\n%s @equiv{}\n",
			format_chunk_name(Initial_setup_name, 0, "code chunk"))
		print Example_start
	} else if (/^@end initial_setup[[:space:]]*$/) {
		print Example_end
	} else {
		x = expand_tabs($0, Tabstop)
		gsub(/[@{}]/, "@&", x)
		print x
	}

	next
}
@

@node jrweave last bit
@section Passing Everything Else Through

Any line in the input document that doesn't match
one of the commands described in the previous @value{SECTION}s
should be left alone.
Thus, the final thing to do is to pass all other lines on through
to the output.

@(jrweave@) =
@<Default @code{print} statement for @command{jrweave}@>
@

This statement @emph{must} be the last active rule in @command{jrweave}.

@<Default @code{print} statement for @command{jrweave}@> =
Pass == 2 { print }
@

@node jrweave expanding tabs
@section Expanding Tabs

@TeX{} treats tabs like single spaces.  However, people writing code
like to use tabs to handle indentation.  There are two ways to manage
having real tabs: either set your editor to expand tabs to spaces upon
input, or use real tabs, and expand them when creating the document with
@command{jrweave}.  Since I happen to like using tabs,@footnote{A habit of
over 30 years that is just too hard to break.} I have chosen the latter.

In addition, preserving literal tabs in a file can be critical: this is most
applicable to @file{Makefile} files but perhaps matters for other kinds
of files as well.

@(jrweave@) =
@<Expand tabs for @command{jrweave}@>
@

Although POSIX-style systems usually expand tabs to every eight columns,
that's a bit much for printed documents like what Texinfo produces.
So, I have chosen to set tabs at every four columns. This choice can be
adjusted using the @option{-v} option to @command{gawk}.

@<Expand tabs for @command{jrweave}@> =
BEGIN {
	if (Tabstop == 0)
		Tabstop = 4		# default tab stops
}
@

I recommend using whatever appropriate magic in the @value{TWJR}
input document that will set the tab stop to whatever you prefer
in your favorite editor.  For @uref{http://www.vim.org, Vim},
I use this line, which also switches on syntax highlighting
appropriate to Texinfo. It must be placed within the first four
or so lines of the file.

@example
@@c vim: filetype=texinfo tabstop=4
@end example

The code that expands tabs is fairly straightforward. It first makes
sure that the chosen tab stop is at least two or more.  Next it splits
the string into an input array, @code{chars}, and starts copying the
input to the output (@code{out}) one character at a time. The cases
are as follows:

@table @asis
@item A newline
Upon encountering a newline, we must reset our idea of the output
column back to zero. This is the variable @code{k}.

@item A non-tab
Copy the character to the output and increase @code{k} by one.

@item A tab
Replace the tab with a space and then add spaces until the
output column has reached the next tab stop.

The algorithm is borrowed from the original Berkeley Unix
@command{expand} program, written in C, where arrays are zero-based,
and the check can be made using the bitwise AND operator to see
if more characters remain.
@end table

At the end, we call @code{join()} to convert the @code{out}
array into a single string which can be returned.

@findex @code{expand_tabs()} function, @command{jrweave}
@<Expand tabs for @command{jrweave}@> =
# expand_tabs --- expand tabs in the string

function expand_tabs(string, tabstop,	chars, out, i, j, k, n)
{
	if (tabstop < 2)
		fatal(_"expand_tabs: tabstop %d < 2\n", tabstop)

	n = split(string, chars, "")
	j = k = 0
	for (i = 1; i <= n;) {
		if (chars[i] == "\n") {
			out[j++] = chars[i++]
			k = 0
			continue
		}

		if (chars[i] != "\t") {
			out[j++] = chars[i++]
			k++
			continue
		}
		i++	# skip the tab

		do {
			out[j++] = " "
			k++
		} while (and(k, tabstop-1) != 0)
	}

	return join(out, 0, j, SUBSEP)
}
@

(I suppose this could have been broken out into small chunks
with preceding explanatory text; I'm not sure it would have
made a noticeable difference since this is not a big function.)

@node jrweave helper functions
@section Helper Functions For @command{jrweave}

We finish up with the helper functions needed
by @command{jrweave}.

@(jrweave@) =
@<Helper functions for @command{jrweave}@>
@

The first is a simple function to remove non-alphanumeric
characters from chunk names:

@findex @code{sanitize_name()} function, @command{jrweave}
@<Helper functions for @command{jrweave}@> =
function sanitize_name(name)
{
	gsub(/[^[:alnum:]]/, "-", name)

	return name
}
@

In a related sense, this function removes Texinfo
markup from text, in order to use it as the argument for
@code{@@sortas}.

@findex @code{remove_markup()} function, @command{jrweave}
@<Helper functions for @command{jrweave}@> =
function remove_markup(text,	result)
{
	result = gensub(/([^@])(@[[:alpha:]]+[{]([^}]+)[}])/, "\\1\\3", "g", text)
	result = gensub(/@TeX[{][}]/, "TeX", "g", result)

	return result
}
@

Next are functions to do various kinds of formatting.
Since formatting anchors and references are similar,
a helper function does the work, with the main functions
delegating to it:

@findex @code{format_anchor_or_ref()} function, @command{jrweave}
@findex @code{format_xref()} function, @command{jrweave}
@<Helper functions for @command{jrweave}@> =
function format_anchor_or_ref(type, name, defn,
								clean_name, result)	# locals
{
	clean_name = sanitize_name(name)
	if (defn > 0)
		result = sprintf("@%s{%s-%d}", type, clean_name, defn)
	else
		result = sprintf("@%s{%s}", type, clean_name)

	return result
}

function format_xref(name, defn)
{
	return format_anchor_or_ref("ref", name, defn)
}
@

Formatting anchors is not so simple. If there is only one
definition, a value of zero should be passed to
@code{format_anchor_or_ref()}.

@findex @code{format_anchor()} function, @command{jrweave}
@<Helper functions for @command{jrweave}@> =
function format_anchor(name, cur_defn, total_defns,		defn)
{
	if (total_defns == 1)
		defn = 0
	else if (cur_defn <= total_defns)
		defn = cur_defn
	return format_anchor_or_ref("anchor", name, defn)
}
@

Finally, the formatting of chunk names varies based on whether
it is file chunk or a code chunk.

@findex @code{format_chunk_name()} function, @command{jrweave}
@<Helper functions for @command{jrweave}@> =
function format_chunk_name(name, count, type,
							result, left, right, style) # locals
{
	if (type == "file chunk") {
		left = "@{"
		right = "@}"
		style = "file"
	} else if (type == "code chunk") {
		left = "<"
		right = ">"
		style = "i"
	} else
		fatal(_"format_chunk_name: Unknown chunk type `%s'\n", type)

	if (count > 0 && Numbered_chunks)
		result = sprintf("@r{%s@%s{%s} @oldnum{%d}%s}",
						left, style, name, count, right)
	else
		result = sprintf("@r{%s@%s{%s}%s}", left, style, name, right)

	return result
}
@
@c +++++++++++++++++++ end of new +++++++++++++++++++++++++

@node Bootstrapping
@chapter Bootstrapping The System

@quotation
Who will compile the compiler?@footnote{Yes, I made that up.}
@author Lady Ada Lovelace
@end quotation

This @value{CHAPTER} discusses the initial bootstrapping process,
presents the initial setup recipe for the @value{TWJR} software,
presents a @file{Makefile} for ongoing maintenance, and describes
how to access the software using Git.

@menu
* Initial bootstrapping::       Bringing up the system from scratch.
* The initial setup::           The initial setup.
* The Makefile::                Keeping the system going.
* Downloading from git::        Downloading from the Git repository.
@end menu

@node Initial bootstrapping
@section Bringing Up The System From Scratch

Any literate programming system needs to be bootstrapped. As a first step,
the tangle program, if it is compiled, must be given to the compiler as
straight code.  This is true also if it is written in a scripting language.

Once you have a working tangle program, you can generate the final one from
the literate program, and also extract the weave program. Once you have the
weave program, you can generate a document to be formatted with @TeX{},
@LaTeX{}, @command{troff}, a DocBook processor, or whatever.  So that's
the basic idea.

How did I bootstrap things?

Initially, I wrote a minimal version of @command{jrtangle}, called
@command{jrtangle0}.  I wrote this in straight @command{gawk}, but with
many more comments than usual.  This was not so hard: The fact that
@command{awk} lets you put functions anywhere in the file, along with
allowing multiple @code{BEGIN} and @code{END} blocks anywhere in the file,
mitigates some of the need for building up chunks in the way that is
normally done with @command{WEB}-like tools.  When writing the bootstrap
version of @command{jrtangle}, it was straightforward to write in a linear
fashion and just drop in yet another @code{BEGIN} block or function.

The next step was then to take @command{jrtangle0}, integrate it into
@file{texiwebjr.twjr} and start breaking it up into chunks and adding
more prose.  From that point on I could add enhancements as well.
I continued to use @command{jrtangle0} until @command{jrtangle} could
bootstrap itself.  This is established when the following works:

@example
jrtangle0 texiwebjr.twjr    @ii{Create jrtangle}
mv jrtangle jrtangle1       @ii{Rename it}
./jrtangle1 texiwebjr.twjr  @ii{Run it}
cmp jrtangle jrtangle1      @ii{Should produce no output}
@end example

Occasionally, I found a bug or more general case that I had
not handled in @command{jrtangle0}. In such cases, I went
back and fixed the problem there too, so that I could continue
to bootstrap from ground zero.

Once @command{jrtangle} is functional, the next step is to write
@command{jrweave}.  This, of course, can be done from the start
in a literate fashion, since @command{jrtangle} creates it for us.

The initial version of @command{jrweave} was pretty simple. It handled
@samp{@@ifweave @r{@dots{}} @@end ifweave} and
@samp{@@iftangle @r{@dots{}} @@end iftangle}, and the earliest supported
additional commands (@code{@@post_create}). It then simply formatted the
file and code chunks using @code{@@example}, escaping the characters
@samp{@@}, @samp{@{}, and @samp{@}}, and expanding tabs.  This was enough
to produce a straight Texinfo document that could be formatted and viewed
onscreen (say, with a PDF viewer).

From that point on, I could add one feature at a time, and test the
features as I went along.

@node The initial setup
@section The Initial Setup

Mainly to check out the code, we provide an initial setup recipe.
And for fun, we print it:

@initial_setup
if [ ! -d bin ]
then
#	echo making bin
	mkdir bin
# else
#	echo bin is there
fi
@end initial_setup

@print_initial_setup

@node The Makefile
@section Keeping Things Going With @command{make}

Of course, no project would be complete without a @file{Makefile}.
This one does the minimum, which is to bootstrap @command{jrtangle}
and @command{jrweave} and to create a PDF of the @value{DOCUMENT}.

In addition, it can create HTML and DocBook versions, including a PDF
from the DocBook XML file, using @command{dblatex}.  The latter is
considerably uglier than the file produced by @TeX{}, Computer Modern
fonts not withstanding.  It does prove, though, that it is possible
to create valid DocBook from a @value{TWJR} file.

If I ever go the route of making a real distribution, there are many
more common targets that should be added here. For now though, this
suffices.

@(Makefile@) =
@<GPL 3 Copyright statement@>

# FIXME: Maybe make the Makefile depend on the .twjr file.
# FIXME: Run xmllint on the xml file.

SOURCE = texiwebjr.twjr
TEXISOURCE = texiwebjr.texi

all: jrweave jrtangle pdf docbook html info

jrweave jrtangle: $(SOURCE)
	./bootstrapping/jrtangle0 $(SOURCE)

$(TEXISOURCE): $(SOURCE) jrweave
	./jrweave $(SOURCE) > $(TEXISOURCE)

pdf: texiwebjr.pdf

texiwebjr.pdf: $(TEXISOURCE)
	texi2dvi --pdf --batch --build-dir=texiwebjr.t2p \
		-o texiwebjr.pdf texiwebjr.texi

docbook: texiwebjr.xml

texiwebjr.xml: $(TEXISOURCE)
	makeinfo --docbook $(TEXISOURCE)

dbpdf: docbook
	fop -xml texiwebjr.xml -pdf texiwebjr-fop.pdf -xsl /usr/share/xml/docbook/stylesheet/docbook-xsl/fo/docbook.xsl

html: texiwebjr.html

texiwebjr.html: $(TEXISOURCE)
	makeinfo --no-split --html $(TEXISOURCE)

info: texiwebjr.info

texiwebjr.info: $(TEXISOURCE)
	makeinfo --no-split $(TEXISOURCE)

clean:
	rm -f texiwebjr.html texiwebjr.info texiwebjr.xml
	rm -f texiwebjr.texi texiwebjr.pdf
	rm -fr texiwebjr.t2p

distclean: clean
	rm jrweave jrtangle Makefile
@

@node Downloading from git
@section Downloading From The Git Repository

The code for @value{TWJR} is available from GitHub.
To get it, you will need a @uref{http://git-scm.org, Git}
client of some kind.  The instructions here presume a command-line
style client.

@example
git clone https://github.com/arnoldrobbins/texiwebjr
cd texiwebjr
./bootstrapping/jrtangle0 texiwebjr.twjr
make
@end example

When you're done, you will have @command{jrweave}, @command{jrtangle} and
the @file{Makefile} in your current directory and a @file{texiwebjr.pdf}
PDF file as well.  This file may be printed or viewed on screen with a
PDF viewer.

You will need to have a working @TeX{} installation, and also a version
of @command{texi2pdf} and @command{makeinfo}.  The latter should come from
the Texinfo 5.2 distribution, or newer.

These instructions assume that you have @command{gawk} version 4.0
or later installed in @file{/usr/bin}. If not you will have to
use something like @samp{gawk -f ./jrweave @r{@dots{}}} (assuming that
@command{gawk} 4.0 or later is in your search path somewhere).

@cindex @command{gawk} distribution
And of course, if you don't have @command{gawk}, the canonical
incantation is:

@example
wget http://ftp.gnu.org/gnu/gawk/gawk-5.0.0.tar.gz
gzip -d < gawk-5.0.0.tar.gz | tar -xpf -
cd gawk-5.0.0
./configure && make
# magic here to install, often sudo make install
@end example

You should, of course, get the latest version of @command{gawk}
that has been released.

@node Evaluation and Futures
@chapter Evaluation and Future Work

@cindex Kernighan, Brian W.@:
At this point, we can stop and look at what we've accomplished. Together
@command{jrtangle} and @command{jrweave} comprise around 1,340 lines of
code.  That's a substantial amount of @command{awk}.@footnote{Especially
as Brian Kernighan keeps insisting that two lines is the optimal size
for an @command{awk} program!} Nonetheless, I think that the literate
programming style eased the development and makes understanding the
program pretty easy.  What follows are some semi-random thoughts.

What you see is the final product; it evolved during development.
Unfortunately, there is no good way to present, in a static document
like this one, the dynamics of the software development, and to show
how the program changed as it grew.@footnote{The morbidly curious can
go grovelling through the history in the Git repository.
However, I'm not sure that's a good use of anyone's time.} The best I
can do is make some appropriate notes in the prose in the right places;
e.g., that chunks are stored without the final newline.

Additionally, I don't claim that there is anything earth-shaking or
stunningly innovative here.  What I have done is show that a useful,
usable literate programming system can be created in a few weeks of
spare-time work, with under 1,350 lines of @command{awk}. That's pretty
good.  Of course, ``the proof is in the pudding;'' I won't know how good
a job I've really done until I use @value{TWJR} to write something else,
of medium to large size.@footnote{Since writing this, I have written
one @command{awk} script of about 400 lines. I have yet to write
something large (for some definition of ``large'') in C or C++.}

There are a few design decisions that might need revisiting once
I start using @value{TWJR} for ``real work.''

@itemize @bullet
@item
Always producing every file and letting the user supply code to
deal with updating it may be too time consuming. On the other hand,
when compared with actual compilation time for large C and C++ files,
the time in this step may turn out to be neglible.

@item
Right now @command{jrweave} always sends the generated Texinfo file to
standard output. Perhaps instead the output file should be derived from
the name of the input file with the same kind of ``did it change?'' checking
being done by @command{jrweave}, instead of this having to be done in the
@file{Makefile} (if at all).

@end itemize

I can think of several possible future enhancements:

@itemize @bullet
@item
Sidebars are currently indexed in the regular concept index.
It might be reasonable to place them into a separate index which
the author would either print or merge into the concept index.

@item
Some kind of general mechanism for adding in @code{#line}
statements for C and C++.

@item
Similar to @command{noweb}, the ability to include leading prose
in the generated code as a comment.

@item
A way to specify that a chunk should include the leading text on
all expanded lines.  This would be useful, for example, with the
GPL copyright block.  In a @code{Makefile} or shell script I could
perhaps do something like this:

@example
#! /bin/sh
#
# @@<GPL 3 Copyright statement@@>	@@c jrtangle_use_prefix
#
@end example

@noindent
This would precede all the lines of the copyright block with @samp{#}, whereas
in C or C++ code, it would look like this:

@example
/*
 * @@<GPL 3 Copyright statement@@>	@@c jrtangle_use_prefix
 */
@end example

Of course, we can't just do this all the time; it would break something
like

@example
if (@@<some condition@@>) @dots{}
@end example

@noindent
in the case that @code{@@<some condition@@>} was a multiline condition.

@item
One thing that definitely still needs doing is to check
for chunks that were defined but not expanded.

@item
Another thing is to look for case differences and or whitespace
differences (that is, typos) in chunk names. Neither program is
very robust about this right now.
@end itemize

Some random thoughts noted during development:

@itemize @bullet
@item
Copy--paste development causes problems.  The original operations for
file chunks and code chunks were similar but not identical.  This made
it hard to get the code right and eventually led to a large refactoring
of the whole business (file + code)
@iftex
@math{\times}
@end iftex
@docbook
&times; @c
@end docbook
@ifnottex
@ifnotdocbook
x
@end ifnotdocbook
@end ifnottex
(@command{jrtangle} + @command{jrweave}).
Of course, ultimately, this was a major improvement.

@item
Formatting the generated code to preserve indentation was a good
design decision.  This makes it enormously easier to work with from the
@command{gawk} debugger, since the standalone code is also legible.

@item
Many things that would normally be put in functions end up as code chunks
when writing literately.  This might be more of a bug than a feature,
since code chunks may end up misusing global variables that would
otherwise have been local in functions.  It also leads to duplicated
code in the generated programs.

@item
One nice thing about literate programming is that you can polish the
documentation without it affecting the code. It's easy to rename chunks,
and even move around where you discuss the code chunks, as long as their
order in the file chunks remains unchanged.
@end itemize

@node Command summary
@appendix Alphabetic List of @value{SHORTTITLE} Commands and Variables

Here is the complete list of commands that @value{TWJR}
adds to the Texinfo markup language.

@table @code
@item @@(@var{filename}@@) =
Start or add to the definition of @var{filename}'s contents.
@xref{jrtangle file chunks}, and @ref{jrweave file chunks}.

@item @@<@var{chunkname}@@> =
Start or add to the definition of a code chunk named @var{chunkname}.
@xref{jrtangle code chunks}, and @ref{jrweave code chunks}.

@item @@allowindexbraces
Cause index entries that start with a brace to be correctly
indexed under @samp{@{}.
@xref{jrweave additional macros}.

@item @@dquotexrefs
In @TeX{} output, change cross references to enclose chapter
and section titles in double quotes instead of in square
brackets.
@xref{Cross-reference quoting}.

@item @@EMAIL@{@var{real}, @var{spelled}@}
Use @var{spelled} as the email address for HTML output.
Use @var{real} as the email address for anything else.
This is to help avoid having one's email address harvested
by spammers.
@xref{jrweave additional macros}.

@item @@file_chunk_full_defs
Print the full list of file chunk definition
points after each file chunk.
@xref{jrweave additional macros}.

@item @@file_update @var{file} @var{directory} @var{suffix}
Set the @var{directory} and @var{suffix} parameters to use for @var{file}'s
file update recipe. @xref{jrtangle avoiding update}.

@item @@file_update_recipe @r{@dots{}} @@end file_update_recipe
Replace the default file update recipe with the enclosed code lines.
This should be system level (``shell'') code.
@xref{jrtangle avoiding update}.

@item @@FIXME@{@var{text}@}
Add a ``FIXME'' note to the text for use during writing.
@xref{jrweave additional macros}.

@item @@hideurls
In @TeX{} output, URLs from @code{@@url} and @code{@@uref}
are formatted as links, instead of being placed into
the body of the text.

@item @@iftangle @r{@dots{}} @@end iftangle
Pass the enclosed lines through when tangling and delete
them when weaving.
@xref{jrtangle ifweave iftangle}, and
@ref{jrweave ifweave iftangle}.

@item @@ifweave @r{@dots{}} @@end ifweave
Pass the enclosed lines through when weaving and delete
them when tangling.
@xref{jrtangle ifweave iftangle}, and
@ref{jrweave ifweave iftangle}.

@item @@initial_setup @r{@dots{}} @@end initial_setup
Define the actions to be done before @command{jrtangle}
creates any files. @xref{jrtangle before everything}.

@item @@numberedchunks
Do use numbered chunks in the printed document.
@xref{jrweave additional macros}.

@item @@oldnum@{@var{number}@}
Set @var{number} in @TeX{}'s @code{\oldstyle} font. This
is for use by @command{jrweave}, and not directly
by the author of a document.

@item @@pdflinkcolor @r{[} @var{red green blue} @r{]}
In @TeX{} output, links within the document (such as
cross references) show up in the color defined by
@var{red}, @var{green}, and @var{blue}.
If not provided, ``dark red'' is used.

@item @@post_create @var{filename} @var{command to run}
Arrange to run @var{command to run} after @var{filename}
has been created. @xref{jrtangle after creation}.

@item @@print_code_defs
Print an alphabetically sorted list of code chunk definitions
at this point in the document.
@xref{jrweave print code defs}.

@item @@print_code_refs
Print an alphabetically sorted list of code chunk references
at this point in the document.
@xref{jrweave print code refs}.

@item @@print_file_defs
Print an alphabetically sorted list of file chunk definitions
at this point in the document.
@xref{jrweave file defs}.

@item @@print_initial_setup
Print the initial setup code at this point in the document.
@xref{jrweave print setup recipe}.

@item @@sidebar @var{title} @r{@dots{}} @@end sidebar
Create a sidebar named @var{title}.
For DocBook output, create a real @code{<sidebar>} element.
For anything else, fake it using Texinfo's @code{@@cartouche}
environment.  @xref{jrweave sidebars}.

@item @@urllinkcolor @r{[} @var{red green blue} @r{]}
In @TeX{} output, URLs from @code{@@url} and @code{@@uref}
formatted as links show up in the color defined by
@var{red}, @var{green}, and @var{blue}.
If not provided, ``dark red'' is used.

@item @@use_example
After occurrences of this command, code is formatted
using @code{@@example}, until a subsequent @code{@@use_smallexample}
command. The initial default is to use @code{@@example}.
@xref{jrweave choosing code size}.

@item @@use_smallexample
After occurrences of this command, code is formatted
using @code{@@smallexample}, until a subsequent @code{@@use_example}
command. The initial default is to use @code{@@example}.
@xref{jrweave choosing code size}.

@end table

The following @command{awk} variables can be set on the
command line with the @option{-v} option to change how
@command{jrtangle} and @command{jrweave} behave:

@table @code
@item Debug
This should be one or more keywords which are searched for a regexp match.
If there's a match, an appropriate debugging message is printed.

@item Shell_debug
This can be set to an arbitrary string that is prefixed
to any commands to be run by @code{system()}. If you do so,
it is up to you to get the command syntax right.

@item Tabstop
This controls how many spaces are used to expand real tab characters.
@end table

@node File Chunk Summaries
@appendix File Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions. The code chunk definitions
and references are printed after each chunk in the body
of the @value{DOCUMENT}.
and the code chunk references.

@print_file_defs

@node Use of @command{gawk} features
@appendix Features Specific to @command{gawk}

The code for @command{jrtangle} and @command{jrweave} makes free use of
features that are only in @command{gawk}. This @value{APPENDIX} notes them, with
some discussion of what would have to be done to use a POSIX standard
version of @command{awk}.

In practice, @command{gawk} is quite portable, and it's likely that if
you're reading this and are interested in using @value{TWJR} yourself,
then you won't mind building @command{gawk} and having it available.

@table @asis
@item The @code{gensub()} function
The @value{TWJR} code takes advantage of @code{gensub()}'s ability to
pull out the pieces that match subparentheses. This would have to be
done more manually in a standard @command{awk}, using @code{match()}
and @code{substr()}.

@item The four-argument version of @code{split()}
The fourth argument to @code{split()} is an array that holds the text
in between the pieces that matched the pattern.  This too would have
to be done manually using @code{match()} and @code{split()}.

@item Bitwise functions
The @code{and()} function is used in the calculation for expanding
tabs. This would have to be done differently in a standard @command{awk}.

@item Translatable strings
This one is easy. A translatable string looks like the concatenation of
a variable named @samp{_} with a string constant. Such constructs should
work as-is in other @command{awk} versions.
Of course, it would be nice if I were to follow through by setting
@code{TEXTDOMAIN} and setting up the @file{Makefile} to produce the
@file{texiwebjr.pot} file. Let's just move on, shall we?

@item Multidimensional Arrays
Here too, the standard syntax could be made to work, by contorting
the code slightly. However, the multidimensional arrays are cleaner.

@item @code{length(@var{array})}
In at least one place, we use the minor extension that
@code{length(@var{array})} returns the number of elements in the
array.  Both Brian Kernighan's @command{awk} and current versions of
@command{mawk} support this feature. I don't think it has yet made its
way into POSIX, though.
@end table

@node Bibliography
@unnumbered Bibliography

@enumerate

@item
@uref{http://www-cs-faculty.stanford.edu/~knuth/lp.html,
@cite{Literate Programming}},
Donald E.@: Knuth,
Center for the Study of Language and Information, 1992.
ISBN-10: 0937073806,
ISBN-13: 978-0937073803.

@item
@cindex @command{gawk} documentation
@uref{http://www.gnu.org/software/gawk/manual/,
@cite{GAWK: Effective AWK Programming}},
Arnold D. Robbins,
Free Software Foundation, Cambridge, Massachusetts, 2013.
Distributed with the source code for @command{gawk}.

@item
@uref{http://www-cs-faculty.stanford.edu/~knuth/abcde.html,
@cite{Computers & Typesetting}}. This five-volume boxed set of hardback
books contains the documentation and source for both @TeX{} and @MF{},
as well as the Computer Modern fonts.  It is worthwhile to obtain the
``millennium edition'' which includes fixes for all known issues up to
the last time it was printed.  My copy is dated 2011.

@enumerate a
@item
Volume A, @cite{The @TeX{}book},
Donald E.@: Knuth,
Addison-Wesley, Reading, Massachusetts, 1984.
ISBN-10 0-201-13447-0.
ISBN-13: 978-0201134476.

@item
Volume B, @cite{@TeX{}: The Program},
Donald E.@: Knuth,
Addison-Wesley, Reading, Massachusetts, 1986.
ISBN-10: 0-201-13437-3.
ISBN-13: 978-0201134377.

@item
Volume C, @cite{The @MF{}book},
Donald E.@: Knuth,
Addison-Wesley, Reading, Massachusetts, 1986.
ISBN-10: 0-201-13445-4.
ISBN-13: 978-0201134452.

@item
Volume D, @cite{@MF{}: The Program},
Donald E.@: Knuth,
Addison-Wesley, Reading, Massachusetts, 1986.
ISBN-10: 0-201-13438-1.
ISBN-13: 978-0201134384.

@item
Volume E, @cite{Computer Modern Typefaces},
Donald E.@: Knuth,
Addison-Wesley, Reading, Massachusetts, 1986.
ISBN-10: 0-201-13446-2.
ISBN-13: 978-0201134469.
@end enumerate

@item
@uref{http://www.ctan.org,
The Comprehensive @TeX{} Archive Network}.

@end enumerate

@node Concept Index
@unnumbered Index

@printindex cp

@bye

TODO:
- Full indexing of variables and functions
- Write a script to create texiwebjr.pot ?
- Option to print out file update recipe?
