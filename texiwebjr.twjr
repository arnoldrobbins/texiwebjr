\input mftmac % for Metafont logo
\input texinfo   @c -*-texinfo-*-
@c vim: filetype=texinfo tabstop=4
@c %**start of header (This is for running Texinfo on a region.)
@setfilename texiwebjr.info
@settitle TexiWeb Jr.---A Super Simple Literate Programming System
@c %**end of header (This is for running Texinfo on a region.)

@c Change how xref titles are quoted.
@dquotexrefs
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear

@xrefautomaticsectiontitle on

@c The following information should be updated here only!
@c This sets the edition of the document.

@c These apply across the board.
@set UPDATE-MONTH January, 2014
@set EDITION 0.6

@set TITLE TexiWeb Jr.@:---A Super Simple Literate Programming System
@set SHORTTITLE TexiWeb Jr.@:

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@ifnottex
@macro MF{}
@sc{METAFONT}
@end macro
@end ifnottex

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c @finalout
@end iftex

@copying
@docbook
<para>Published by:</para>

<literallayout class="normal">Arnold David Robbins
P.O. Box 354
Nof Ayalon
D.N. Shimshon 9978500
ISRAEL
Email: <email>arnold@@skeeve.com</email>
URL: <ulink url="http://www.skeeve.com/">http://www.skeeve.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; 2013, 2014
Arnold David Robbins
All Rights Reserved.</literallayout>
@end docbook

@ifnotdocbook
Copyright @copyright{} 2013, 2014 @*
Arnold David Robbins @*
All Rights Reserved.
@end ifnotdocbook
@sp 1
The @command{jrtangle} and @command{jrweave} programs are copyright
@copyright{} 2013, 2014 by Arnold David Robbins. They are published under
the conditions of the GNU General Public License, version 3.
@sp 1
The explanatory text provided in this document may be reproduced verbatim
but may not be otherwise copied or modified.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.
@end copying

@c The name of our program. Setting it as a macro makes it
@c easier to change later.
@set TWJR @sc{TexiWeb Jr.@:}

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@c @setchapternewpage odd

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@titlepage
@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author Arnold D. Robbins

@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
Arnold David Robbins @*
P.O. Box 354 @*
Nof Ayalon @*
D.N. Shimshon 9978500 @*
ISRAEL @*
Email: @EMAIL{arnold@@skeeve.com,arnold AT skeeve.com} @*
URL: @url{http://www.skeeve.com/} @*

@insertcopying
@end ifnotdocbook
@end titlepage

@set DRAFT @i{DRAFT}

@iftex
@headings off
@evenheading @thispage @| @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @| @thispage
@end iftex

@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top General Introduction
@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This file documents @value{TWJR}, a program suite for Literate Programming
on top of the Texinfo document formatting markup language.

@insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@menu
* Preface::                        Preface.
* Introduction::                   Introduction.
* jrtangle code::                  The code for @command{jrtangle}.
* jrweave code::                   The code for @command{jrweave}.
* Bootstrapping::                  Chicken and egg issues.
* Evaluation and Futures::         Evaluation and future work.
* Command summary::                Alphabetic list of @value{TWJR} commands.
* Code Chunk Summaries::           Alphabetic lists of code chunks by
                                   definition and by reference.
* Use of @command{gawk} features:: Features Specific to @command{gawk}.
* Bibliography::                   Reference material.
* Concept Index::                  The concept index.

@detailmenu
* Lit prog and me::                Literate programming and me.
* Audience::                       Who should read this @value{DOCUMENT}.
* Overview::                       An overview of the @value{DOCUMENT}.
* Conventions::                    Typographical conventions.
* Acknowledgements::               Acknowledgements.
* Litprog intro::                  Quick intro to Literate Programming.
* Processing a document::          Creating code and documentation.
* Why texinfo::                    Why build on top of Texinfo.
* Why awk::                        Why implement in @command{awk}.
* jrtangle ifweave iftangle::      Text inclusion/exclusion for
                                   @command{jrtangle}.
* jrtangle file chunks::           Processing file chunks for
                                   @command{jrtangle}.
* jrtangle start chunk collection:: Starting chunk collection.
* jrtangle finish chunk collection:: Finishing file and code chunk collection.
* jrtangle collecting chunk lines:: Collecting chunk lines.
* jrtangle finish file chunk::     Completing file collection for
                                   @command{jrtangle}.
* jrtangle code chunks::           Processing code chunks for
                                   @command{jrtangle}.
* jrtangle error checking::        Checking for errors in @command{jrtangle}.
* Expanding code chunks::          Expanding code chunks into straight code.
* jrtangle before everything::     Doing something before extracting any
                                   files.
* jrtangle avoiding update::       Leaving unmodified files alone.
* jrtangle after creation::        Doing something after creating a file.
* Common Chunks::                  Common code chunks and functions.
* jrweave two passes::             Two pass design.
* jrweave initial code::           Initial Stuff and Printing A Warning.
* jrweave choosing code size::     Choosing the code size.
* jrweave ifweave iftangle::       Text inclusion/exclusion for
                                   @command{jrweave}.
* jrweave language additions::     Extra stuff for authors.
* jrweave additional macros::      Macros for writing documents.
* jrweave sidebars::               Providing sidebars.
* jrweave @TeX{} control::         Additional features for @TeX{}.
* jrweave file chunks::            Collecting and formatting file chunks.
* jrweave code chunks::            Collecting and formatting code chunks.
* jrweave print setup recipe::     Printing the initial setup recipe.
* jrweave file defs::              Printing file definitions.
* jrweave code defs and refs::     Printing code definitions and references.
* jrweave print code defs::        Printing code definitions.
* jrweave print code refs::        Printing code references.
* jrweave delete jrtangle code::   Removing stuff for @command{jrtangle}.
* jrweave last bit::               Passing everything else through.
* jrweave expanding tabs::         Expanding tabs.
* jrweave helper functions::       Helper functions for @command{jrweave}.
* Initial bootstrapping::          Bringing up the system from scratch.
* The initial setup::              The initial setup.
* The Makefile::                   Keeping the system going.
* Downloading from git::           Downloading from the @command{git}
                                   Repository.
* File Definitions::               Source files by definition.
* Code Chunk Definitions::       Code chunks by definition.
* Code Chunk References::        Code chunks by reference.
@end detailmenu
@end menu

@c @summarycontents
@contents

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword

@node Preface
@unnumbered Preface

Literate programming is a programming style created originally by
Professor Donald E.@: Knuth, of Stanford University.
Programming well this way requires the author of a program to
present clear explanations of both how his program functions
and why it is written in the way it is. The discipline involved
thus leads to better programs.

The Texinfo markup language is the official documentation markup
language of the GNU Project. It makes writing program documentation
pleasant. In addition, these documents can be converted to multiple
formats for end use. The most important formats (in my
opinion) are HTML for viewing with a Web browser, @TeX{} for printing,
and DocBook for publishing.

This @value{DOCUMENT} describes @value{TWJR}, a system that provides
literate programming on top of the Texinfo markup language.

@menu
* Lit prog and me::             Literate programming and me.
* Audience::                    Who should read this @value{DOCUMENT}.
* Overview::                    An overview of the @value{DOCUMENT}.
* Conventions::                 Typographical conventions.
* Acknowledgements::            Acknowledgements.
@end menu

@node Lit prog and me
@unnumberedsec Literate Programming and Me

I probably first encountered literate programming in Jon Bentley's
@cite{Programming Pearls} columns in CACM in the mid-1980s. Sometime
later I found and read Knuth's book on the subject (@pxref{Bibliography}).

I do know that I was dabbling with it as early as sometime in the first
half of 1998, since that is when I found and fixed a race condition in
@command{noweb}'s @command{troff} backend.

From October of 1999 through September of 2001, I did some consulting work
for Mike Brennan, the author of
@uref{http://www.invisible-island.net/mawk, @command{mawk}}
and a good friend.  We used
Mike's @command{mweb} system@footnote{As I recall it, sometime earlier I
had pointed him at literate programming. He created his @command{mweb} in
1996.} for the work. @command{mweb} used @command{notangle} for tangling.
For weaving, it used
@command{markup} from @command{noweb} with a backend written
(of course) in @command{mawk}, and a custom set of @TeX{} macros.
This was certainly the largest body of literate code I have written
to date.  (At this point, I don't recall the details of @command{mweb},
but undoubtedly it was an influence for @value{TWJR}) @c no period!

In April of 2003, I used @command{noweb} to rewrite the input record
handling of @command{gawk}, considerably simplifying it in the process. To
this day, there have been very few bugs in it, and it certainly qualifies
as ``golden code.''

Alas, though. I've done very little literate programming since, until now.
I hope that this will be the start of a new phase for me, where I can write
code that will be appealing to read and enjoyable to write.

@node Audience
@unnumberedsec Intended Audience

@quotation
When all you have is a hammer, everything looks like a nail.
@author Anonymous
@end quotation

You should read this @value{DOCUMENT} if you are interested in
literate programming, and in seeing how one programmer decided to
create his own literate programming system for use in writing
large programs.

You may also find this @value{DOCUMENT} interesting if you like
programming using scripting languages, as the code is written in
@command{awk}, the author's favorite hammer.

@c Scale figure to 4.5 inches which is good for both smallbook
@c and regular.  TeX will scale height also automatically.
@float Figure,third-way
@caption{Third Way (@url{http://xkcd.com/1285})}
@center @image{third_way, 5in, , Third Way}
@end float

Many people today are used to using WYSIWYG document creation programs.
Texinfo uses the older, batch-formatting model of document creation, where
you @dfn{mark up} the text with formatting instructions, and the input
does not physically resemble the output. (@xref{third-way}.)  Such systems
may take longer to learn, but ultimately they provide more control over
your document, and you spend your time thinking about your content instead
of fighting the document creation program's ideas of how to do things.
Thus, you should be familiar with the Texinfo markup language.

You should also be familiar with the @command{awk} programming language.
In particular, @value{TWJR} makes use of additional features in
@command{gawk} (the GNU implementation of Awk).@footnote{This
in hardly surprising, since I maintain @command{gawk}.}

You should also understand at least the basics of @command{make}
and @file{Makefile} construction, since it is important that
@value{TWJR} work in a Unix-style command-line environment
with @command{make}.

@node Overview
@unnumberedsec What Is Covered

This @value{DOCUMENT} provides the full source and description
of the @value{TWJR} literate programming system.
The @value{CHAPTER}s and what they cover are as follows.

@c No period when TWJR ends a sentence, since it has a period in it.
@ref{Introduction}, briefly introduces literate programming
and describes some of the motivation for @value{TWJR}

@ref{jrtangle code}, presents the code for @command{jrtangle}, the
``tangling'' component of @value{TWJR}

@ref{jrweave code}, presents the code for @command{jrweave}, the
``weaving'' component of @value{TWJR}

@ref{Bootstrapping}, describes the issues involved in bringing up a
literate programming system from scratch and shows the initial setup
recipe. It also presents the @file{Makefile} used for ongoing maintenance,
and for lack of a better place, describes how to obtain the source for
the system using @command{git}.

@ref{Evaluation and Futures}, provides some brief discussion
of various design decisions, as well as looking at possible
future features to add.

@ref{Command summary}, presents an alphabetic list of all
the @value{TWJR} commands. It also lists the variables that
a user may set using @command{gawk}'s @option{-v} option to
affect the behavior of the programs.

@ref{Code Chunk Summaries}, provides
alphabetic lists of source files by definition, and of
code chunks by definition and by reference.

@ref{Use of @command{gawk} features}, looks at the
@command{gawk}-specific features that are used with a brief
description of what to use instead if you wish to use a
standard version of @command{awk} instead of @command{gawk}.@footnote{Although
why anyone would want to do so is beyond me.}

@ref{Bibliography}, lists books that may be of interest.

At least one index follows the bibliography.

@node Conventions
@unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

Finally, I sometimes break with tradition, and write in the first
person, instead of using ``the royal we.''  However, use of ``we''
is appropriate during discussional prose; I would like you, the reader,
to feel as if you're engaging in a conversation with me, the author.
To that end, ``we'' is entirely correct.

@node Acknowledgements
@unnumberedsec Acknowledgements

I would like to acknowledge the following people.

@itemize @bullet
@item
@cindex Kernighan, Brian W.@:
@cindex Aho, Alfred V.@:
@cindex Weinberger, Peter J.@:
Alfred V.@: Aho, Peter J.@: Weinberger, and Brian W.@: Kernighan,
for inventing the @command{awk} language.

@item
@cindex Stallman, Richard M.@:
Richard M.@: Stallman for inventing the Texinfo markup language.

@item
Donald E.@: Knuth for inventing literate programming.

@item
Norman Ramsey for inventing @command{noweb}.

@item
Ben Pfaff for inventing the original TexiWeb.

@item
@cindex Berry, Karl
Karl Berry for his infinite patience with my questions about
and suggestions for Texinfo.

@item
Reviewers here @enddots{}
@end itemize

@node Introduction
@chapter Introduction

This @value{DOCUMENT} documents @value{TWJR}, an intentionally
simple literate programming system.

This @value{CHAPTER} introduces the basic concepts behind literate
programming, and describes how to use these tools to create literate
programs.  It also discusses why @value{TWJR} is built on top Texinfo
and implemented in @command{awk}.

@menu
* Litprog intro::               Quick intro to Literate Programming.
* Processing a document::       Creating code and documentation.
* Why texinfo::                 Why build on top of Texinfo.
* Why awk::                     Why implement in @command{awk}.
@end menu

@node Litprog intro
@section What Is Literate Programming?

@cindex McPhee, Patrick TJ
@quotation
Without wanting to be elitist, the thing that will prevent literate
programming from becoming a mainstream method is that it requires thought
and discipline. The mainstream is established by people who want fast
results while using roughly the same methods that everyone else seems
to be using, and literate programming is never going to have that kind
of appeal. This doesn't take away from its usefulness as an approach.
@author Patrick TJ McPhee
@end quotation

@cindex Knuth, Donald E.@:
@dfn{Literate programming} is a programming style invented by
@uref{http://www-cs-faculty.stanford.edu/~knuth/, Professor Donald E.@: Knuth}
of Stanford University for implementing the
@uref{http://www.tug.org, @TeX{} document formatter}
and @MF{} font-creation programs.

A literate program is a mixture of program fragments that do some
particular task, and explanatory prose describing what the code is
doing. Preferably, the prose also describes @emph{why} the code is
implemented in a particular fashion.

The significant difference over simply using lots of comments is
that code is presented in the order that makes the most sense for
the human reading and understanding the program, as opposed to the
order needed for the programming language's compiler or interpreter.
More information and pedagogy may be found on
@uref{http://www.literateprogramming.com, the literate programming website}.

Knuth's original @command{WEB} system was built on top of and for use
with Pascal.  When this was done in the early 1980s, Pascal was just about
the only language that was popular, generally portable, and basically
usable for large programs (despite a number of constraints). @command{WEB}
provided a number of facilities to make Pascal programming easier, and
also ``pretty printed'' the code in the finished document.  (Today Knuth
uses @uref{http://www-cs-faculty.stanford.edu/~knuth/cweb.html,
@command{CWEB}}, which is similar to the original @command{WEB}
but is intended for use with C.)

@cindex Ramsey, Norman
@cindex Pfaff, Ben
Many literate programming tools have been developed since then.
@value{TWJR} is inspired by two in particular:
@uref{http://www.cs.tufts.edu/~nr/noweb/, Norman Ramsey's @command{noweb}},
and
@uref{http://searchcode.com/codesearch/view/14097352, Ben Pfaff's TexiWeb}.

@cindex @command{noweb} literate programmng tool
@command{noweb} makes a conscious attempt to provide a minimal additional
markup over and above the document formatting language. It also attempts
to be portable to any markup language, not just @TeX{} or @LaTeX{},
and to any programming language.  Finally, it is programmable, with
several stages in a pipeline and a documented intermediate format,
making it easily extensible.  It is the ``minimal additional markup''
aspect of @command{noweb} that I find particular appealing.

@cindex TexiWeb literate programmng tool
TexiWeb was created by Ben Pfaff for writing his
@uref{http://adtinfo.org/, AVL library}.
It builds on the Texinfo markup language, which at first glance is
exactly what I was looking for: Texinfo + Literate Programming.
However, TexiWeb has two drawbacks: it is poorly documented,
and it assumes that the code is written in C, and thus does
pretty-printing.

I wanted to be able to use Texinfo, and to write code in any language.
Thus, @value{TWJR}, which acknowledges TexiWeb as its inspiration,
and the Texinfo bias, but which is built from scratch.

@node Processing a document
@section Processing A Document

Traditionally, a web document is processed in two different ways,
towards two different ends.

@table @dfn
@item Weaving
This process turns a literate program into a form that can be processed
for printing.  Knuth's @command{WEB} provided @command{WEAVE}, which
created a straight @TeX{} document.  The @command{noweb} suite has
@command{noweave}.

The @value{TWJR} weaving program is called @command{jrweave}.  It reads
a @value{TWJR} document and produces a Texinfo document which can then
be processed by @command{texi2dvi} or @command{texi2pdf} to produce
a printable file. (It can also be processed with @command{makeinfo}
to produce Info, HTML, DocBook, or Texinfo XML.)

@item Tangling
This process turns a literate program into straight code that can be
either run directly (scripting languages), or compiled (C, C++, etc.).
Knuth's @command{WEB} provided @command{TANGLE}, which created a straight
Pascal program.  The @command{noweb} suite has @command{notangle}.

The @value{TWJR} tangling program is called @command{jrtangle}.  It reads
a @value{TWJR} document and produces the source files defined therein for
running or compiling.
@end table

By convention, @value{TWJR} files have a @file{.twjr} extension.
This is valuable, since the @TeX{} by-product files generally have
two- or three-character extensions. Thus, for a document @file{foo.twjr},
you can safely say @samp{rm foo.?? foo.???} (in a Bourne-compatible
shell) to remove the by-product files without accidentally nuking
your primary document.

As part of writing a @value{TWJR} program, you should also include
a @file{Makefile} in your document.  If you're wondering about
bootstrapping, then you're thinking ahead. We will get to that.

@node Why texinfo
@section Why Build On Top of Texinfo

Why Texinfo?  Good question, I'm glad you asked.

I have written books in @command{troff}, Texinfo, and DocBook (both SGML
and XML).  I have also written a little bit in straight HTML. Of all
of these, I find that Texinfo is the easiest to use.  It is expressive
enough for distinguishing the different kinds of things that need special
designation in a printed document, and for structuring a document in
the traditional way, without being so verbose that my fingers end up
hurting when I'm done working on a document after a few hours.

While my first preference might have been to use @command{noweb}, since I
am familiar with it, it does not support Texinfo. Even though @LaTeX{} is a
more powerful markup language, I didn't want to climb that learning curve
just to use @command{noweb}.  Also, I felt that it might be easier---and
certainly more @emph{fun}---to write my own small literate programming
system than to add a Texinfo back end to @command{noweb}.@footnote{The
truth is that doing something like this has been in the back of my mind
for close to 20 years; I finally decided to ``just do it.''}

Similarly, TexiWeb already does what I would seem to need, but its lack
of documentation makes it harder to use, and its enforced pretty-printing
is definitely undesirable for code not written in C. I prefer code to
look like code (constant-width font, no pretty-printing) and I want to be
able to use any kind of code in my code chunks, including @command{awk},
Makefiles, shell scripts, whatever.

Additionally, TexiWeb seems focused primarily on @TeX{}.  The advantage
of Texinfo is that it can be translated into HTML and also DocBook XML,
and I would like to preserve those advantages.

Finally, I think it's better for the author to do the indexing manually
than to rely on the literate programming tool, although that opinion
may change as this evolves.

@node Why awk
@section Why Implement In @command{awk}

Why write in @command{awk}? Good question. I glad you asked this one too.

I got involved with the
@uref{http://www.gnu.org/software/gawk/, GNU Awk project}
late in 1987.  I have been the sole maintainer and the primary author
of its documentation since 1994.  The language is small, elegant, and
generally quite powerful.  @command{gawk}, in particular, adds many
useful features over the original Unix (and POSIX standard) @command{awk}.

Part of what makes maintaining @command{gawk} enjoyable is that I like
using the language itself, on a daily basis.

Weaving and tangling primarily involve a lot of text manipulation, and
this is an area where @command{awk} shines. In particular, there's no
need to worry about low-level details like I/O and memory management;
the expression of what needs to be done has an almost one-to-one
correspondence to the code that does it!

@value{TWJR} gives me the opportunity to enjoy three of my favorite
activities all at the same time: writing with Texinfo, programming
in @command{gawk}, and doing that programming in the literate
style.@footnote{This may explain why so many literate programmers have
chosen to create their own literate programming systems.  So we now get
a little psychology thrown in as well.}

@node jrtangle code
@chapter Tangling: The @command{jrtangle} Program

The major additional syntactic features over Texinfo are @dfn{file chunks}
and @dfn{code chunks}. Each starts with the name of the chunk in special
bracketing sequences, and continues until a line with just a single
@samp{@@} sign on it.

@table @code
@item @@(@var{filename}@@) =
Start or add to the definition of @var{filename}'s contents.

@item @@<@var{chunkname}@@> =
Start or add to the definition of a code chunk named @var{chunkname}.
@end table

@quotation NOTE
Due to the implementation of @command{jrweave}, file chunks and code
chunks share the same ``name space,'' meaning that you will
cause severe confusion if you attempt to use the same name
as a source file name and as a code chunk name.
@end quotation

@menu
* jrtangle header::             Getting Started.
* jrtangle ifweave iftangle::   Text inclusion/exclusion for @command{jrtangle}.
* jrtangle file chunks::        Processing file chunks for @command{jrtangle}.
* jrtangle code chunks::        Processing code chunks for @command{jrtangle}.
* jrtangle error checking::     Checking for errors in @command{jrtangle}.
* Expanding code chunks::       Expanding code chunks into straight code.
* jrtangle before everything::  Doing something before extracting any files.
* jrtangle avoiding update::    Leaving unmodified files alone.
* jrtangle shell debug::        Debugging shell commands run by @command{jrtangle}.
* jrtangle after creation::     Doing something after creating a file.
* Common Chunks::               Common code chunks and functions.
@end menu

@node jrtangle header
@section Getting Started

Let's get started.  Here is the code for @command{jrtangle}.

The file starts with the obligatory @samp{#!} header and copyright
statements, followed by code chunks and functions common to both
@command{jrtangle} and @command{jrweave}.

@cindex @code{@@post_create} command, @command{jrtangle}
@post_create jrtangle chmod +x jrtangle
@(jrtangle@) =
@<Shebang header@>
@<Common Chunks@>
@<Helper Functions@>
@

On my system, the latest version of @command{gawk} lives
in @file{/usr/local/bin}. This should be changed on
your system if it's not correct.

@<Shebang header@>=
#! /usr/local/bin/gawk -f
@

As a general note, @command{jrtangle} and @command{jrweave} need features
introduced in @command{gawk} 4.0; @emph{earlier versions will not work}.

The common chunks and functions are described later in this @value{CHAPTER}.
However, we define one of them now, so that the license comes
out at the top of the file. The actual license text is provided later.

@<Common Chunks@>=
@<GPL 3 Copyright statement@>
@

@node jrtangle ifweave iftangle
@section Document Sections Exclusive to Tangling and Weaving

One nice thing in TexiWeb are @samp{@@iftangle @r{@dots{}} @@end iftangle} and
@samp{@@ifweave @r{@dots{}} @@end ifweave} bracketing commands.  Those should
be dealt with early on.  They do the obvious thing: include lines that
should be used only for one operation or the other.  Note that these
have to be done differently for @command{jrtangle} and @command{jrweave};
each one ignores what the other one passes through.

@page
@(jrtangle@) =
@<Handle @code{ifweave} and @code{iftangle} for @code{jrtangle}@>
@

@cindex global variables, name convention
The following code is straightforward. We see here the first instance
of any global variables: @code{Line_numbers}. Instead of having lots
of different global variables, they are grouped by function into
associative arrays.  Here we see @code{Line_numbers["ifweave"]}
and @code{Line_numbers["iftangle"]} to help in error checking. If an
@code{@@ifweave} block is encountered while @command{jrtangle} thinks
it's processing an @code{@@iftangle} block, then something got messed
up somewhere.  Note also the convention that global variables start with
a capital letter.

@vindex @code{Line_numbers} variable
@vindex variable, @code{Line_numbers}
@cindex @code{@@ifweave} command, @command{jrtangle}
@cindex @code{@@iftangle} command, @command{jrtangle}

@<Handle @code{ifweave} and @code{iftangle} for @code{jrtangle}@>=
# ifweave lines should be removed

/^@ifweave[[:space:]]*$/, /^@end ifweave[[:space:]]*$/ {
	if ("iftangle" in Line_numbers)
		fatal(_"cannot nest @ifweave inside @iftangle\n")

	# start of construct, save line number
	if (/^@ifweave[[:space:]]*$/)
		Line_numbers["ifweave"] = (FILENAME ":" FNR)

	# end of construct, delete line number
	if (/^@end ifweave[[:space:]]*$/)
		delete Line_numbers["ifweave"]

	# simply skip these lines, this is tangling
	next
}

# For tangling we remove the bracketing control lines and let anything
# in between fall through.

/^@iftangle[[:space:]]*$/, /^@end iftangle[[:space:]]*$/ {
	if ("ifweave" in Line_numbers)
		fatal(_"cannot nest @iftangle inside @ifweave\n")

	# start of construct, save line number, skip this line
	if (/^@iftangle[[:space:]]*$/) {
		Line_numbers["iftangle"] = (FILENAME ":" FNR)
		next
	}

	# end of construct, delete line number, skip this line
	if (/^@end iftangle[[:space:]]*$/) {
		delete Line_numbers["iftangle"]
		next
	}

	# otherwise fall through into the rest of the code
}
@

@node jrtangle file chunks
@section Processing File Chunks for @command{jrtangle}

The next part of interest is to handle file chunks. File chunks
specify the name of a file and include straight code intermixed with
references to code chunks.

@menu
* jrtangle start chunk collection::  Starting chunk collection.
* jrtangle finish chunk collection:: Finishing file and code chunk collection.
* jrtangle collecting chunk lines::  Collecting chunk lines.
* jrtangle finish file chunk::       Completing file collection for
                                     @command{jrtangle}.
@end menu

@node jrtangle start chunk collection
@subsection Starting File and Code Chunk Collection

It turns out that because code chunks also include straight code mixed
with references to code chunks, their processing is quite similar to
that of file chunks.  After fully implementing @command{jrtangle} and
almost fully implementing @command{jrweave}, it became clear that I was
using a lot of similar-but-not-quite-identical code in several places,
and that it would be better to go back and unify the processing of the
two kinds of chunks. This would ultimately simplify the final code;
any remaining duplication would come from reuse of code chunks instead
of from copy-paste-edit.

We start by placing the two patterns that search for chunks one right
after the other; they are then followed by the code that terminates
collection (for the standalone @samp{@@} sign) and the collection code.
We will see the code chunk processing in @ref{jrtangle code chunks}.

@(jrtangle@) =
@<Initial code chunk processing pattern for @command{jrtangle}@>
@<Process file chunks for @code{jrtangle}@>
@

As mentioned, file chunks start with @samp{@w{@@(filename.c@@) =}} in column
1. Unlike TexiWeb and like @command{noweb}, we don't require @samp{+=}
to add more stuff to a definition. We just use @samp{=} and figure it
out. File and code chunks end with a single @samp{@@} on a line by itself,
with the @samp{@@} in column 1.

@code{File_chunk_pattern} describes the regexp for matching the first
line of a file chunk. It is a variable since it needs to be used for
matching and with @code{gensub()}. This is better than repeating the
regexp in the code.

@<Definition of @code{File_chunk_pattern}@> =
File_chunk_pattern = "^@\\(([^)]+)@\\)[[:space:]]*=[[:space:]]*$"
@

It turns out that file chunk processing has some common bits
for both @command{jrtangle} and @command{jrweave}.

@<Process file chunks for @code{jrtangle}@>=
$0 ~ File_chunk_pattern {
	@<Common file chunk initial processing@>
	next
}
@

In turn, the file processing shares code with the chunk processing by
putting the appropriate values into variables used while collecting both
kinds of chunks.

@<Common file chunk initial processing@> =
Chunk_type = "file chunk"
Pattern = File_chunk_pattern
Debug_pat = "filename"
@<Common chunk initial processing@>
@

Instead of using a range pattern, we use a boolean flag; this lets us
avoid special-casing the first and last lines.

@vindex @code{Flags} variable
@vindex variable, @code{Flags}
The code checks that
we're not already gathering a chunk; if we are, someone left off a trailing
@samp{@@} somewhere. The @code{check_unfinished()} function also checks other
possible things that may have gone wrong.
Similar to @code{Line_numbers}, @code{Flags} is a global array of
flags (boolean values) indexed by strings indicating what we're doing.

@vindex @code{Debug} variable
@vindex variable, @code{Debug}
@cindex debugging, @code{Debug} variable
The check against @code{Debug} uses a nice trick. By using
@command{gawk}'s @option{-v} option, we can set @code{Debug} to any value,
such as @code{"filename code"} and debug as many different aspects of
the program simultaneously as we might want.  Use of the @command{gawk}
built-in debugger also helps considerably.

@<Common chunk initial processing@> =
new_chunk = gensub(Pattern, "\\1", 1)
if (Flags[Chunk_type]) {
	fatal(_"%s start of %s found while still collecting %s\n",
		Chunk_type, new_chunk, Current_chunk)
}
check_unfinished()

Flags[Chunk_type] = TRUE
Line_numbers[Chunk_type] = (FILENAME ":" FNR)
Current_chunk = new_chunk
Chunk_info[Current_chunk]["type"] = Chunk_type

if (Debug ~ Debug_pat)
	printf("saw new %s %s\n", Debug_pat, Current_chunk) > "/dev/stderr"
@

The @code{BEGIN} block sets up some constants.

@<Common Chunks@>=
BEGIN {
	@<Constants used by @command{jrtangle} and @command{jrweave}@>
}
@

And here is the first set of constants:

@<Constants used by @command{jrtangle} and @command{jrweave}@> =
TRUE = 1
FALSE = 0
@<Definition of @code{File_chunk_pattern}@>
@

@node jrtangle finish chunk collection
@subsection Finishing File and Code Chunk Collection

Here is the @samp{@@} sign that ends the input file.  It also ends
code chunks.  Since we are manually simulating a range pattern, this
@emph{must} come before the code that collects the lines in file and
code chunks. Otherwise the collection never stops!@footnote{Guess
how I discovered that one@enddots{} Duh.}

@page
@<Process file chunks for @code{jrtangle}@>=
@<Handle terminating at-sign for file and code chunks@>
@

Here too, what to do upon seeing the terminating @samp{@@} is shared
across @command{jrtangle} and @samp{jrweave}.

@<Handle terminating at-sign for file and code chunks@> =
/^@[[:space:]]*$/ {
	if (Flags["file chunk"])
		end_file_gathering()
	else if (Flags["code chunk"])
		end_code_gathering()
	else
		warning(_"unmatched terminating @-sign: ignored\n")

	Chunk_lines = ""
	Flags[Chunk_type] = FALSE
	Line_numbers[Chunk_type] = ""
	Chunk_type = ""

	next
}
@

@node jrtangle collecting chunk lines
@subsection Collecting Chunk Lines

After some experimentation, things are simplest if file contents and
code chunks do @emph{not} have the final terminating newline. Code that
outputs file contents must remember to add the final newline.

Collecting the lines is simple.
Collect each line and append it.
Any embedded code chunks are expanded at the end.
Collecting lines is also common between the two programs.

@<Process file chunks for @code{jrtangle}@>=
@<Collect chunk lines@>
@

@<Collect chunk lines@> =
Flags["file chunk"] || Flags["code chunk"] {
	if (Chunk_lines == "")
		Chunk_lines = $0
	else
		Chunk_lines = Chunk_lines "\n" $0

	next
}
@

@node jrtangle finish file chunk
@subsection Completing File Collection for @command{jrtangle}

Once we have all the lines, we save them in @code{File_contents},
which is an associative array whose indices are the file names
and the corresponding values are each file's lines.

@findex @code{end_file_gathering()} function, @command{jrtangle}
@<Process file chunks for @code{jrtangle}@>=
# end_file_gathering ---finish up collecting a file

function end_file_gathering()
{
	if (Current_chunk in File_contents)
		File_contents[Current_chunk] = \
			File_contents[Current_chunk] "\n" Chunk_lines
	else
		File_contents[Current_chunk] = Chunk_lines

	if (Debug ~ /filename/)
		printf("finished collecting file %s\n",
						Current_chunk) > "/dev/stderr"
}
@

@node jrtangle code chunks
@section Processing Code Chunks for @command{jrtangle}

The next major piece of logic is the collection of code chunks.

@(jrtangle@) =
@<Process code chunks for @code{jrtangle}@>
@

Code chunks are like file chunks. They start with @samp{@@<chunk-name@@>
=} and end with a standalone @samp{@@} sign. The logic and handling are
essentially identical to what we just did for files, especially now that
we are sharing code chunks.

First the pattern to match.  My initial attempt at a pattern was:

@c set it off since it's too long for being embedded inline
@example
^@@<([^@@]+)@@>[[:space:]]*=[[:space:]]*$
@end example

@noindent
However, this didn't work as soon as I used a chunk name that included Texinfo
commands.  Ooops.  So now the pattern is more general.

Since we have to bootstrap from this file, and @samp{@@<(.+)@@>}
looks like a code chunk name, we create it using string concatenation:

@<Constants used by @command{jrtangle} and @command{jrweave}@> =
Code_chunk_pattern = "^@" "<(.+)" "@>[[:space:]]*=[[:space:]]*$"
@

Next the logic. Here too, there are common bits shared between
@command{jrtangle} and @command{jrweave}:

@<Initial code chunk processing pattern for @command{jrtangle}@> =
$0 ~ Code_chunk_pattern {
	@<Common code chunk initial processing@>
	next
}
@

@<Common code chunk initial processing@> =
Chunk_type = "code chunk"
Pattern = Code_chunk_pattern
Debug_pat = "code"
@<Common chunk initial processing@>
@

What to do after gathering the lines depends upon the program.
For @command{jrtangle} we store the lines for later use.

@findex @code{end_code_gathering()} function, @command{jrtangle}
@<Process code chunks for @code{jrtangle}@>=
# end_code_gathering --- complete the collecting lines of code chunk

function end_code_gathering()
{
	if (Current_chunk in Code_contents)
		Code_contents[Current_chunk] = \
			Code_contents[Current_chunk] "\n" Chunk_lines
	else
		Code_contents[Current_chunk] = Chunk_lines

	if (Debug ~ /code/)
		printf("finished collecting %s\n",
					Current_chunk) > "/dev/stderr"
}
@

And that's it!  The chunk collection and chunk termination code
should handle code chunks as well.

@node jrtangle error checking
@section Checking for Errors

Here is the error checking code. First add it to both files:

@<Common Chunks@>=
# Error checking:

# Use brackets to avoid triggering the warning on ourselves!
/(^<[@])|(>[@]([[:space:]]*=[[:space:]]*)?$)/	{
	# Ditto, with concatenation
	warning("<" "@ or >" "@ used instead of @" "< or @" ">\n\t%s\n",
			$0)
}

END {
	check_unfinished()
}
@


There are two classes  of helper functions used in expanding code chunks;
those needed in both @command{jrtangle} and @command{jrweave}, and those
needed just for @command{jrtangle}.

Checking for unfinished chunks is the same for both @command{jrtangle}
and @command{jrweave}. This is the first of the shared helper functions,
@code{check_unfinished()}.  We will see more functions later.

@findex @code{check_unfinished()} function
@<Helper Functions@> =
# check_unfinished --- print a fatal error when an unfinished code or
#			file section is detected. Also ifweave / iftangle.

function check_unfinished()
{
	if (Flags["file chunk"])
		fatal(_"unfinished file section (started at %s)\n",
			Line_numbers["file chunk"])
	else if (Flags["code chunk"])
		fatal(_"unfinished code section (started at %s)\n",
			Line_numbers["code chunk"])

	if ("ifweave" in Line_numbers)
		fatal(_"unfinished @ifweave section (started at %s)\n",
			Line_numbers["ifweave"])

	if ("iftangle" in Line_numbers)
		fatal(_"unfinished @iftangle section (started at %s)\n",
			Line_numbers["iftangle"])
}
@

@node Expanding code chunks
@section Expanding Code Chunks

Expanding code chunks is the hardest part of @command{jrtangle}.
In particular, any expanded chunks may contain other chunks that
need expanding. This naturally leads to a recursive implementation,
which in turn requires checking that a code chunk's expansion
does not include itself, either directly or indirectly.

Experimentation has shown that it's necessary to manage the
recursion carefully; after a chunk has been expanded we must
clear our record of it. For example, consider a chunk like this:

@noindent
@:<@i{example chunk} @oldnum{42}> @equiv{}
@example
x = func1()
@r{<@i{Do special task} @oldnum{57}>}
y = func2()
@r{<@i{Do special task} @oldnum{57}>}
@dots{}
@end example

@noindent
After expanding @code{@@<Do special task@@>} the first time, we have
to forget that we've done it, so that we can safely expand it the
second time.

@(jrtangle@) =
@<Expand code chunks@>
@

We will work through the code top down:

@<Expand code chunks@>=
# Finishing off code is easy, at least from 10,000 feet.

END {
	@<Do any initial setup@>

	dump_files()

	if (Debug ~ /code/)
		dump_chunks()
}
@

Of course, we have delayed the inevitable only a little bit.  At the
outermost level, the code loops through all the files and writes them out,
letting @code{expand_code_chunks()} do the real work.

In practice, if a source file's contents haven't changed we don't want
to write them out again, since this could easily cause @command{make}
to recompile a file that doesn't need recompiling. In large programs
this is a Bad Thing. (The @code{update_recipe} array used in the following
chunk takes care of this; for explanation, @pxref{jrtangle avoiding update}).

As a side note, it may be that dumping all the files every time is a
bad idea. If experience shows us that this is so, this is where to make
the change, along with new code to take a command-line option indicating
which file(s) to extract.

@findex @code{dump_files()} function, @command{jrtangle}
@<Expand code chunks@>=
# dump_files --- create files and update them as needed

function dump_files(	i, s, update_recipe)
{
	for (i in File_contents) {
		s = expand_code_chunks(File_contents[i])

		create_update_recipe(i, update_recipe)
		printf("%s\n", s) > update_recipe["output"]
		close(update_recipe["output"])

		# update the file if necessary
		update_recipe["recipe"] = (Shell_debug update_recipe["recipe"])
		system(update_recipe["recipe"])

		@<Run ``post create'' commands@>
	}
}
@

@noindent
(The @code{Shell_debug} variable is discussed in @ref{jrtangle shell debug}.)

In turn, @code{expand_code_chunks()} initializes for recursion checking
and then passes the buck to @code{do_expand_code_chunks()}.

@findex @code{expand_code_chunks()} function, @command{jrtangle}
@<Expand code chunks@>=
# expand_code_chunks --- expand embedded code chunks.

function expand_code_chunks(contents)
{
	@<Reset for recursion@>

	return do_expand_code_chunks(contents)
}
@

By the time we get here, it isn't actually so hard.
@code{do_expand_code_chunks()} splits the contents into individual
lines. It then loops over the results.  If a line does not contain any
chunk names, then the result can be kept verbatim, and it is copied into
the @code{results} array.

On the other hand, if it does, it has to be expanded, and that is done
down in @code{expand_one_line()}.

@findex @code{do_expand_code_chunks()} function, @command{jrtangle}
@<Expand code chunks@>=
# do_expand_code_chunks --- do the actual work to expand code chunks

function do_expand_code_chunks(contents,
								nlines, lines, results, i, j) # locals
{
	nlines = split(contents, lines, "\n")

	for (i = 1; i <= nlines; i++) {
		if (lines[i] !~ Chunk_name_pattern) {
			results[i] = lines[i]
		} else
			results[i] = expand_one_line(lines[i])
	}

	return join(results, 1, nlines, "\n")
}
@

Let's go ahead and define @code{Chunk_name_pattern}, which is
used throughout the expansion process.

@<Constants used by @command{jrtangle} and @command{jrweave}@> =
Chunk_name_pattern = "@<[^>\n]+@>"
@

@code{expand_one_line()} does all the work to isolate chunk names, expand
them, and put everything back together with reasonable indentation.
At the end, if the expanded line contains further code chunks, it
recursively calls @code{do_expand_code_chunks()} to process them as well.

@findex @code{expand_one()} function, @command{jrtangle}
@<Expand code chunks@>=
# expand_one_line --- expand a line with code chunk references

function expand_one_line(input_line,	parts, chunk_names, nparts,
										num_names, code_lines, i, j)
{
	@<Split the input line into text parts and chunk names@>
	@<Check for recursive expansion@>
	@<Get the code lines, insert white space if needed@>
	@<Put the line back together, expanding code chunks along the way@>

	if (code_lines ~ Chunk_name_pattern) {
		# get any further code chunks, recursively
		return do_expand_code_chunks(code_lines)
	} else
		return code_lines
}
@

The following code uses the four-argument version of @code{split()};
the fourth argument is an array of strings where each element is what
matched the separating regexp.  Element @var{i} in the @code{chunk_names}
array is what came after element @var{i} in the @code{parts} array.

@<Split the input line into text parts and chunk names@> =
nparts = split(input_line, parts, Chunk_name_pattern, chunk_names)
num_names = length(chunk_names)
@

In our case, the split is made using @code{Chunk_name_pattern}, causing
@code{parts} to contain the parts of the line before and after each
chunk name. The fourth argument, @code{chunk_names}, contains the
names of the code chunks and there is more than one element if
there were several chunks referenced on the line.  @code{num_names}
tells us how many chunk names there are.

After splitting, error checking looks to see if the chunk name
is @emph{not} in @code{Code_contents}; if so, then it was never
defined. (That is also an error.)  Next, it checks to see if any of the
found chunk names are already in the process of being expanded. This is
done using a global array named @code{Currently_expanding}.  If present,
it's an error; otherwise the name is entered into the array.

@use_smallexample
@<Check for recursive expansion@> =
# check for recursive expansion
for (i = 1; i <= num_names; i++) {
	j = strip_out_name(chunk_names[i])

	if (! (j in Code_contents))
		fatal(_"expand_one_line: code chunk `%s' used but not defined\n",
			chunk_names[i])

	if (j in Currently_expanding)
		fatal(_"expand_one_line: code chunk `%s' expands itself recursively\n",
			chunk_names[i])
	else
		Currently_expanding[j]++
}
@
@use_example

And way back up in @code{expand_code_chunks()}, we have to empty out the
@code{Currently_expanding} array:

@<Reset for recursion@> =
delete Currently_expanding
@

Here is the next shared helper function, @code{strip_out_name()},
which pulls out the name of the chunk from in between the @samp{@@<}
and the @samp{@@>}:

@findex @code{strip_out_name()} function
@<Helper Functions@>=
# strip_out_name --- get the name from name

function strip_out_name(name,	l)
{
	l = length(name)
	name = substr(name, 3, l - 4)

	return name
}
@

Returning to processing code lines, we start by getting the code associated
with the first chunk.  If the part of the line preceding the first chunk
reference is all white space, we insert that part in front of the text
of each retrieved line. The result is that indentation in the finished,
generated code, looks reasonable.

This too is an explicit design decision. Knuth's original @command{TANGLE}
made the generated code as ugly as possible so that there would be no
temptation to work with it directly.  I don't want to be so draconian.
In particular, when using the @command{gawk} debugger, it really helps
that the code is formatted nicely.

After getting the code body for each chunk we delete it from the
@code{Currently_expanding} array.  This is where we ``forget'' that
we're expanding the chunk for the recursion check.

@<Get the code lines, insert white space if needed@> =
code_lines = code_body(chunk_names[1])
delete Currently_expanding[strip_out_name(chunk_names[1])]

if (input_line !~ ("^" Chunk_name_pattern)) {
	if (parts[1] ~ /^[[:space:]]+$/) {
		# insert leading white space on all lines to get indentation
		gsub(/^|\n/, ("&" parts[1]), code_lines)
	} else {
		code_lines = parts[1] code_lines
	}
}
@

Reassembling the lines is straightforward, the parts are concatenated
with the expansion of the chunks.

@<Put the line back together, expanding code chunks along the way@> =
for (i = 2; i <= nparts; i++) {
	code_lines = code_lines parts[i]
	if (i in chunk_names) {
		code_lines = code_lines code_body(chunk_names[i])
		delete Currently_expanding[strip_out_name(chunk_names[i])]
	}
}
@

We now encounter the first of the helper functions that
are only used by @command{jrtangle}.

@<Expand code chunks@>=
@<Expansion helper functions@>
@

The @code{code_body()} function retrieves the code associated
with a chunk name. Since @code{Code_contents} is indexed by chunk names
without the enclosing brackets, this just strips them off using
@code{strip_out_name()}.

@findex @code{code_body()} function, @command{jrtangle}
@<Expansion helper functions@> =
# code_body --- get the code body associated with name

function code_body(name)
{
	return Code_contents[strip_out_name(name)]
}
@

@node jrtangle before everything
@section Doing Something Before Extracting Any Files

If a @value{TWJR} document describes many source files, it is
logical to want to have subdirectories of different kinds for
different files, and perhaps to run some kind of configuration
or other initialization programs.  To that end, the author of
the document can provide a script (or command invoking a script)
bracketed by @samp{@@initial_setup @r{@dots{}} @@end initial_setup} lines.

Such lines must first be gathered, using the now familiar collection
pattern:

@(jrtangle@) =
@<Collect initial setup lines@>
@

@<Collect initial setup lines@>=
/^@initial_setup[[:space:]]*$/, /^@end initial_setup[[:space:]]*$/ {
	if (/^@initial_setup[[:space:]]*$/) {
		# start of construct, save line number, skip this line
		if ("initial_setup" in Line_numbers)
			fatal(_"cannot nest one @initial_setup inside another\n")
		Line_numbers["initial_setup"] = (FILENAME ":" FNR)
		Initial_setup = ""
	} else if (/^@end initial_setup[[:space:]]*$/) {
		# end of construct, delete line number, skip this line
		delete Line_numbers["initial_setup"]
	} else
		Initial_setup = Initial_setup "\n" $0

	next
}
@

As a result of the @samp{Initial_setup = ""} statement, the last such section
``wins.''  I don't see a reason to make this something that accumulates.

Besides giving the user control over the initial setup, this scheme has the
advantage of being OS-independent; a Windows user can write batch commands
in such a section, whereas a user on a POSIX system can write a shell script,
and @command{gawk} doesn't have to care.

In the @code{END} block that dumps the file, we run the command collected
in @code{Initial_setup}.  Note that it is up to the author of the program
to make sure that the commands are safe to run multiple times in a row.
For example, when creating directories, it is better to write something like
this:

@c manually expand tabs here!
@example
for i in src doc support @r{@dots{}}
do
    if [ ! -d $i ]
    then
        mkdir $i
    fi
done
@end example

@noindent
The above loop checks that each directory does not exist before
creating it.

Just in case, we append a final newline to the text of
@code{Initial_setup}.  Running the @code{Initial_setup} is easy:

@<Do any initial setup@>=
if (length(Initial_setup) > 0) {
	Initial_setup = Initial_setup "\n"
	system(Shell_debug Initial_setup)
}
@

@node jrtangle avoiding update
@section Leaving Unmodified Files Alone

When working with @command{make}, especially in large programs,
it is vital that source files be recompiled only if they have
changed. If @command{jrtangle} blindly recreates every
file every time it runs, @command{make} will constantly
recompile everything from scratch.  This could potentially be
a huge waste of time, even on today's very fast multicore
processors.  So, we have to find some way to only revise
a file on disk when it has actually changed.

This should get interesting.  First, let's talk about 
what @command{noweb} does.  To extract a file, you
tell @command{notangle} which file you are interested in,
and it prints the file contents to standard output. Said
contents may be redirected straight into the destination file.
Or they may be passed to a special program named @command{cpif}
(``copy if'') that compares the new contents to those of the
existing file on disk.  It goes something like this:

@example
notangle -Rfoo.c foo.nw | cpif foo.c
@end example

Then, if @file{foo.c} has not changed, it is not updated.
This is most useful in @file{Makefile} rules, since it prevents
@command{make} from recompiling @file{foo.c} unnecessarily.

I would prefer a mechanism that doesn't require the user to
install (or me to write) a separate program such as @command{cpif}.
In addition, I would like it to be possible to take directory structure
into account, since modern large programs generally group different
components into different subdirectories.

To that end, I think it makes sense to define a @dfn{template}
that describes how to update a file using system-level (shell)
commands.  Then for each file, the author can specify how to
make the substitutions in the template in order to do the update.

We define a default template, with the option for the user
to override it.

The template is defined with @samp{@@file_update_recipe @r{@dots{}}
@@end file_update_recipe}, and each file supplies values to the
template with a line like this:

@example
@@file_update @var{file} @var{directory} @var{suffix}
@end example

@(jrtangle@) =
@<File update recipe handling@>
@

Let's start with the default template. Taking a page from
Autoconf's book, we use @samp{@@@var{param}@@} to
specify the parameters. The possible parameters have hard-coded
names: @code{DIR}, @code{FILE}, and @code{SUFFIX}.
Note the quoting of shell expansions in case (somehow) any of
the various names contain whitespace characters.

@<File update recipe handling@>=
BEGIN {
	Update_recipe = \
		"PATH=/bin:/usr/bin\n" \
		"export PATH\n" \
		"destname=\"@DIR@/@FILE@\"\n" \
		"outname=\"${destname}@SUFFIX@\"\n" \
		"if [ ! -f \"$destname\" ]\n" \
		"then\n" \
		"\tmv \"$outname\" \"$destname\"\n" \
		"elif cmp -s \"$outname\" \"$destname\" > /dev/null\n" \
		"then\n" \
		"\trm \"$outname\"\n" \
		"else\n" \
		"\tmv \"$outname\" \"$destname\"\n" \
		"fi\n"
}
@

The user can override this template.
The collection code should look familiar by now:

@cindex @code{@@file_update_recipe} command, @command{jrtangle}
@<File update recipe handling@>=
/^@file_update_recipe[[:space:]]*$/, \
			/^@end file_update_recipe[[:space:]]*$/ {
	if (/^@file_update_recipe[[:space:]]*$/) {
		# start of construct, save line number, skip this line
		if ("file_update_recipe" in Line_numbers)
			fatal(_"cannot nest one @file_update_recipe inside another\n")
		Line_numbers["file_update_recipe"] = (FILENAME ":" FNR)
		Update_recipe = ""
	} if (/^@end file_update_recipe[[:space:]]*$/) {
		# end of construct, delete line number, skip this line
		delete Line_numbers["file_update_recipe"]
	} else
		Update_recipe = Update_recipe "\n" $0

	next
}
@

Next we have to handle the definitions provided by the user. Well, actually,
this brings up the fact that we need defaults in case the user doesn't
provide values.  At this point, @command{gawk}'s true multidimensional arrays
add some nice clarity to what's going on:

@<File update recipe handling@>=
BEGIN {
	# @default is an unlikely name for a real file
	Update_value["@default"]["DIR"] = "."	# current directory
	Update_value["@default"]["SUFFIX"] = ".tangle_tmp"	# unlikely suffix
	# No default for filename, jrtangle knows it!
}
@

Note that it is is a bad idea to the shell's @code{$$} variable
for any of these values since the string returned to @command{gawk}
for the destination file will not have it expanded!@footnote{Here too,
guess how I found this out.}  If you really want something like
that, it could be done by changing this code to use @command{gawk}'s
@code{PROCINFO["pid"]}.

And @emph{now} we can deal with the user's values:

@cindex @code{@@file_update} command, @command{jrtangle}
@<File update recipe handling@>=
/^@file_update[[:space:]]/ {
	if (NF != 4)
		fatal(_"usage: @file_update name dir suffix\n")

	Update_value[$2]["DIR"] = $3
	Update_value[$2]["SUFFIX"] = $4

	next
}
@

Finally, we have to deal with creating the per-file template
string and the name of the destination file (a temporary one)
in which to place the output.
This function is called in @ref{Expanding code chunks}.

@findex @code{create_update_recipe()} function, @command{jrtangle}
@<File update recipe handling@>=
# create_update_recipe --- create update recipe per file,
#							return dest filename

function create_update_recipe(file, results,
							source_file, dir, suffix, recipe) # locals
{
	if (file in Update_value)
		source_file = file
	else
		source_file = "@default"

	dir = Update_value[source_file]["DIR"]
	suffix = Update_value[source_file]["SUFFIX"]

	delete results

	recipe = Update_recipe
	gsub(/@DIR@/, dir, recipe)
	gsub(/@FILE@/, file, recipe)
	gsub(/@SUFFIX@/, suffix, recipe)

	results["recipe"] = recipe
	results["output"] = (dir "/" file suffix)
}
@

Later on, the recipe is prefixed with the value of @code{Shell_debug},
which turns on execution tracing for shell commands.  (@code{Shell_debug}
is used in a few other places as well.)

@node jrtangle shell debug
@section Debugging Shell Commands Run By @command{jrtangle}

@code{Shell_debug}'s value is set based on the @code{Debug} variable. We
rely on the fact that @command{awk} variables are initialized to the empty
string.  However, if the user has provided a value (via @command{gawk}'s
@option{-v} option) we don't change it.  This is useful in non-POSIX
environments, for example.

@(jrtangle@) =
BEGIN {
	if (Debug ~ /shell/)
		if (length(Shell_debug) == 0)
			Shell_debug = "set -x; "
}
@

@node jrtangle after creation
@section Doing Something After Creating A File

A useful feature is to have the ability to do something to a file after it's
been created.  For example, to make a script file executable.

@(jrtangle@) =
@<Post Creation Tasks@>
@

The way to do this is to specify a line like the following:

@example
@@post_create @var{filename} @var{command to run}
@end example

The @var{command to run} is associated with @var{filename} and run after
the file is created.

@<Post Creation Tasks@>=
/^@post_create[[:space:]]+/ {
	if (NF < 3)
		fatal(_"usage: @post_create filename command\n")
	check_unfinished()

	name = $2
	$1 = $2 = ""
	$0 = $0
	Post_create_commands[name] = $0
}
@

And when dumping files, we run the associated command:

@<Run ``post create'' commands@> =
# run any "post create" command (such as changing mode)
if (i in Post_create_commands)
	system(Shell_debug Post_create_commands[i])
@

@node Common Chunks
@section Common Code Chunks and Functions

This section contains code chunks and @command{awk}
functions that are needed in both @command{jrtangle}
and @command{jrweave}.

@use_smallexample
@<GPL 3 Copyright statement@>=
#
# Copyright (C) 2013, 2014 Arnold David Robbins
# 
# This file is part of TexiWeb Jr., a literate programming system.
# 
# TexiWeb Jr. is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# TexiWeb Jr. is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
@
@use_example

We need the following functions in both programs:

@table @code
@item message()
Print a message to standard error.
This function automatically adds @code{FILENAME} and @code{FNR} to the
message so that the user can tell where the problem is.
The first argument, @code{msg}, indicates what kind of message
is being printed (warning or fatal).

@item fatal()
Print an error message using @code{message()} and then exit.

@item warning()
Print a warning message using @code{message()} but don't exit.

@item join()
Join an array into a single string. This function is copied
from @cite{Effective Awk Programming} (the @command{gawk}
documentation).

@end table

Since @command{gawk} does not have a ``varargs'' facility,
we simply supply 10 arguments; the extras are ignored if the
format string does not reference them.

@findex @code{message()} function
@findex @code{fatal()} function
@findex @code{warning()} function
@findex @code{join()} function
@<Helper Functions@>=
# Helper functions

# message --- write a particular kind of message out to stderr

function message(msg, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
{
	printf("%s:%d: %s: " format, FILENAME, FNR, msg,
		a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) > "/dev/stderr"
}

# fatal --- print a fatal error message and exit.
#	 No varargs, so fake it with lots of parameters.

function fatal(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
{
	message(_"fatal", format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
	exit 1
}

# warning --- print a warning message to stderr
#	 No varargs, so fake it with lots of parameters.

function warning(format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
{
	message(_"warning", format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
}

# join.awk --- join an array into a string
#
# Arnold Robbins, arnold@skeeve.com, Public Domain
# May 1993

function join(array, start, end, sep,    result, i)
{
	if (sep == "")
		sep = " "
	else if (sep == SUBSEP) # magic value
		sep = ""
	result = array[start]
	for (i = start + 1; i <= end; i++)
		result = result sep array[i]
	return result
}
@

We have a need for at least one debugging helper
function.

@(jrtangle@) =
@<Expansion debugging functions@>
@

The @code{dump_chunks()} function may be called if debugging.
Although this is something of a ``helper'' function, as it's
specific to @command{jrtangle}, it should not be included in
the same chunk with the other functions in this @value{SECTION}.

@findex @code{dump_chunks()} function, @command{jrtangle}
@<Expansion debugging functions@> =
# dump_chunks --- print out all the chunks

function dump_chunks(	i, format)
{
	format = "@<%s"
	format = format "@>=\n%s@\n\n"
	for (i in Code_contents)
		printf(format, i, Code_contents[i]) > "/dev/stderr"
}
@

@node jrweave code
@chapter Weaving: The @command{jrweave} Program

Weaving a @value{TWJR} document is in fact the more challenging task.
We want the output to look good, and we also want to keep track of
where chunks are defined and referenced. In addition, we
have to remove any lines that are just for @command{jrtangle},
since Texinfo won't know what to do with them.

@menu
* jrweave two passes::           Two pass design.
* jrweave initial code::         Initial Stuff and Printing A Warning.
* jrweave ifweave iftangle::     Text inclusion/exclusion for
                                 @command{jrweave}.
* jrweave choosing code size::   Choosing the code size.
* jrweave language additions::   Extra stuff for authors.
* jrweave chunk indexes::        Create indices for chunk definition and
                                 references.
* jrweave file chunks::          Processing file chunks.
* jrweave code chunks::          Processing code chunks.
* jrweave print setup recipe::   Printing the initial setup recipe.
* jrweave file defs::            Printing file definitions.
* jrweave code defs and refs::   Printing code definitions and references.
* jrweave delete jrtangle code:: Removing stuff for @command{jrtangle}.
* jrweave last bit::             Passing everything else through.
* jrweave expanding tabs::       Expanding tabs.
* jrweave helper functions::     Helper functions for @command{jrweave}.
@end menu

@node jrweave two passes
@section Processing In Two Passes

The general tradition in literate programming documentation is that each
unique chunk is numbered sequentially from 1, in the order that they are
defined.  Even as chunks are added on to, they are referred to by the
same number.  The numbering is managed by the weaving process; the author
of a literate program does not have to manage this.

An important part of the literate style is that a code chunk may be
referenced before it is defined; in fact this is usually the case.
This raises a difficulty; @command{jrweave} cannot print a chunk
with its associated number if it hasn't yet seen its definition.

It is also traditional, for each chunk, to print a list of other
places where the chunk is defined, and where the chunk is used.
Mike Brennan suggests that furthermore, it is worthwhile to print
a list of sites where the chunks referenced by the current chunk
are defined.

The way to accomplish all this is to use a two-pass design. In the
first pass @command{jrweave} collects information about each
unique file and each unique code chunk, assigning numbers as it
goes.  In the second pass it prints the file, formatting file
and code chunk names appropriately, and writing out the various
cross references.

Things are complicated somewhat by the fact
that Texinfo only gives us anchors and cross references, without
access to just the pages numbers where something occurs.
So, we'll do our best.

We start with the @samp{#!} header and the copyright statement,
and then proceed to arrange to perform two passes over the input.

@post_create jrweave chmod +x jrweave
@(jrweave@) =
@<Shebang header@>
@<Common Chunks@>
@<Set up two passes@>
@<Pass 2 debugging@>
@

In order to allow very large documents split into multiple
files, we copy the full list over.

@<Set up two passes@> =
BEGIN {
	if (ARGC < 2)
		fatal(_"usage: jrweave file.twjr [...]\n")

	Pass = 1
	n = ARGC
	ARGV[ARGC++] = "Pass=2"
	for (i = 1; i < n; i++) {
		@<Disallow standard input for @command{jrweave}@>
		ARGV[ARGC++] = ARGV[i]
	}
}
@

Because of the two-pass nature of the code, we can't
accept standard input:

@<Disallow standard input for @command{jrweave}@> =
if (ARGV[i] == "-" || ARGV[i] == "/dev/stdin")
	fatal(_"jrweave: standard input not allowed\n")
@

This rule serves as a place to set a breakpoint in the
@command{gawk} debugger for when we start the second pass
through the @value{TWJR} source file:

@<Pass 2 debugging@>=
Pass == 2 && FNR == 1 && Debug ~ /pass2/ {
	junk++
}
@

@node jrweave initial code
@section Initial Stuff and Printing A Warning

We print an initial header to remind the user @emph{not} to edit the
generated Texinfo file, and then continue with the helper functions.

@(jrweave@) =
@<Create ``do not edit'' warning@>
@<Helper Functions@>
@

The generated Texinfo file should have a warning at the top
not to edit the file, since this is an easy mistake to
to make (having made it myself!).  We will make it a little
fancy, just for the fun of it.

Printing the header is independent of the two-pass nature of the program
and thus can be done from a @code{BEGIN} block.

@findex @code{print_do_not_edit()} function, @command{jrweave}
@<Create ``do not edit'' warning@>=
BEGIN {
	print_do_not_edit(ARGV[1])
}

# print_do_not_edit --- create and print warning

function print_do_not_edit(filename,	i, pl, pr, l, s, t)
{
	@<Set warning text @code{s} and @code{t}, compute left and right padding @code{pl} and @code{pr}@>
	@<Print a line of percent signs@>

	# print the titles with their padding
	printf("%% %*s%s%*s %%\n", pl, " ", t, pr, " ")
	printf("%% %s %%\n", s)

	@<Print a line of percent signs@>
}
@

Just to be pretty we center the ``do not edit this file'' warning
in the output line. The length of the line in turn depends on the
length of the following line stating the name of the file from
which the Texinfo file was created.
If the length is odd, we have one more space on the right than
on the left.

@<Set warning text @code{s} and @code{t}, compute left and right padding @code{pl} and @code{pr}@> =
t = _"DO NOT EDIT THIS FILE!!!!"
s = sprintf(_"It was created by jrweave from `%s'.", ARGV[1])

l = length(s)
pl = (l - length(t)) / 2	# padding on left side
pr = l - (pl + length(t))	# padding on right side
if (pl * 2 < l)				# account for odd lengths
	pr++
@

Printing a line of percent signs similarly depends on the length
of the text. The @samp{+ 4} is for the space and percent sign on
each side of the text.

@<Print a line of percent signs@>=
for (i = 1; i <= l + 4; i++)
	printf("%%")
printf "\n"
@

@node jrweave ifweave iftangle
@section Document Sections Exclusive to Weaving and Tangling

As in @ref{jrtangle ifweave iftangle}, we need to process
@samp{@@iftangle @r{@dots{}} @@end iftangle} and
@samp{@@ifweave @r{@dots{}} @@end ifweave}. However, we
must do the opposite here of what we did there.

@(jrweave@) =
@<Handle @code{ifweave} and @code{iftangle} for @code{jrweave}@>
@

And without a lot of fanfare, here is the code:

@vindex @code{Line_numbers} variable
@vindex variable, @code{Line_numbers}
@cindex @code{@@ifweave} command, @command{jrweave}
@cindex @code{@@iftangle} command, @command{jrweave}
@<Handle @code{ifweave} and @code{iftangle} for @code{jrweave}@>=
# iftangle lines should be removed

/^@iftangle[[:space:]]*$/, /^@end iftangle[[:space:]]*$/ {
	if (Pass == 1)
		next

	if ("ifweave" in Line_numbers)
		fatal(_"cannot nest @iftangle inside @ifweave\n")

	# start of construct, save line number
	if (/^@iftangle[[:space:]]*$/)
		Line_numbers["iftangle"] = (FILENAME ":" FNR)

	# end of construct, delete line number
	if (/^@end iftangle[[:space:]]*$/)
		delete Line_numbers["iftangle"]

	# simply skip these lines, this is weaving
	next
}

# For weaving we remove the bracketing control lines and let anything
# in between fall through.

/^@ifweave[[:space:]]*$/, /^@end ifweave[[:space:]]*$/ {
	if (Pass == 1)
		next

	if ("iftangle" in Line_numbers)
		fatal(_"cannot nest @ifweave inside @iftangle\n")

	# start of construct, save line number, skip this line
	if (/^@ifweave[[:space:]]*$/) {
		Line_numbers["ifweave"] = (FILENAME ":" FNR)
		next
	}

	# end of construct, delete line number, skip this line
	if (/^@end ifweave[[:space:]]*$/) {
		delete Line_numbers["ifweave"]
		next
	}

	# otherwise fall through into the rest of the code
}
@

@node jrweave choosing code size
@section Choosing The Code Size

Sometimes, code is just too wide for Texinfo's @code{@@example}
sections and it is better to use @code{@@smallexample}.  The
@code{@@use_smallexample} statement causes @command{jrweave}
to use @code{@@smallexample} for all the file and code chunks.

After some experimentation, it makes the most sense to make this
be dynamic, allowing the author to switch things back
and forth.  To that end there is also a @code{@@use_example}
statement.

@(jrweave@) =
@<Switch example environment@>
@

A @code{BEGIN} block sets the default:

@<Switch example environment@> =
BEGIN {
	Example_start = "@example"
	Example_end = "@end example"
}
@

And then we can switch sizes at will:

@cindex @code{@@use_example} command, @command{jrweave}
@cindex @code{@@use_smallexample} command, @command{jrweave}
@<Switch example environment@> =
Pass == 2 && /^@use_smallexample[[:space:]]*$/ {
	Example_start = "@smallexample"
	Example_end = "@end smallexample"
	next
}

Pass == 2 && /^@use_example[[:space:]]*$/ {
	Example_start = "@example"
	Example_end = "@end example"
	next
}
@

@noindent
We then use @code{Example_start} and @code{Example_end} throughout the
rest of the program.

@node jrweave language additions
@section Additions For Writing Documents

Here are some additions to the Texinfo language that
ease both the formatting job and some of the authoring
work.

@menu
* jrweave additional macros::   Macros for writing documents.
* jrweave sidebars::            Providing sidebars.
* jrweave @TeX{} control::      Additional features for @TeX{}.
@end menu

@node jrweave additional macros
@subsection Macros for Writing Documents

The first addition are some macros.
We add them to the output right before the title page.
This is so that the @code{@@EMAIL@{@}} macro can be used
on the copyright page without problems.

@(jrweave@) =
@<Texinfo authoring additions@>
@

@<Texinfo authoring additions@>=
Pass == 2 && /^@titlepage/ {
	print ""
	print "@c Start extra commands added by jrweave\n"
	@<Macro to hide email addresses in HTML@>
	print ""
	@<FIXME macro@>
	print ""
	@<Macro for ``old style'' numbers@>
	print "\n@c End extra commands added by jrweave"

	print ""
	print	# print the line

	next
}
@

For HTML output, we want to be able to provide an email address
as something like ``arnold AT skeeve.com'' in order to avoid
address harvesters and receiving even more spam. To that end
the document can use @samp{@@EMAIL@{arnold@@@@skeeve.com, arnold AT skeeve.com@}}
and things will happen the way we want them to.

@cindex @code{@@EMAIL} macro, @command{jrweave}
@cindex macro, @command{jweave}, @code{@@EMAIL}
@<Macro to hide email addresses in HTML@>=
print "@c For HTML, spell out email addresses, to avoid problems with"
print "@c address harvesters for spammers."
print "@ifhtml"
print "@macro EMAIL{real,spelled}"
print "``\\spelled\\''"
print "@end macro"
print "@end ifhtml"
print "@ifnothtml"
print "@macro EMAIL{real,spelled}"
print "@email{\\real\\}"
print "@end macro"
print "@end ifnothtml"
@

Next is a simple macro to add little ``FIXME'' notes throughout the
manuscript.  It often happens when writing one thing that I think of
something else that needs more work, but I don't want to detour to that
second thing at the moment. This way I can leave myself a note
that will appear in the output so that I will remember to tend to it.
(They should all be fixed by the time everything is done.)

@cindex @code{@@FIXME} macro, @command{jrweave}
@cindex macro, @command{jweave}, @code{@@FIXME}
@<FIXME macro@>=
print "@macro FIXME{text}"
print "@strong{FIXME}: \\text\\"
print "@end macro"
@

Finally, we want to use @TeX{}'s ``old style'' numbers for
numbering the code chunks.  We have to do this in two steps:
first define a macro for @TeX{} itself, and then define a macro
for use in the other formats, which will be just the number itself.

@cindex @code{@@oldnum} macro, @command{jrweave}
@cindex macro, @command{jweave}, @code{@@oldnum}
@<Macro for ``old style'' numbers@>=
print "@tex"
print "\\gdef\\oldnum#1{\\begingroup\\oldstyle #1\\endgroup}%"
print "@end tex"
print ""
print "@ifnottex"
print "@macro oldnum{value}"
print "\\value\\"
print "@end macro"
print "@end ifnottex"
@

@node jrweave sidebars
@subsection Providing Sidebars

Sidebars are blocks of text with a title that are set off to the side in
a printed book (or magazine). They address topics of tangential interest
that are worth discussing but not necessarily part of the main flow of
a section.  Since Texinfo doesn't support them, and I want to be able
to have them, this code provides them. It collects the title and text,
and outputs them twice, once for DocBook, and once for everything
else using Texinfo's @code{@@cartouche} environment.
The title is provided on the opening @code{@@sidebar} line.

@cindex @code{@@sidebar} command, @command{jrweave}
@<Texinfo authoring additions@>=
Pass == 2 && /^@sidebar[[:space:]]+/ {
	sub(/^@sidebar[[:space:]]+/, "", $0)
	Sidebar_title = $0
	Sidebar_body = ""
	Collecting_sidebar = TRUE
	next
}

Pass == 2 && /^@end[[:space:]]+sidebar[[:space:]]*$/ {
	Collecting_sidebar = FALSE
	printf "@cindex sidebar, %s\n", Sidebar_title
	printf "@ifdocbook\n"
		printf "@docbook\n"
		printf "<sidebar><title>%s</title>\n", Sidebar_title
		printf "@end docbook\n"
			print Sidebar_body
		print ""
		printf "@docbook\n"
		printf "</sidebar>\n"
		printf "@end docbook\n"
	printf "@end ifdocbook\n\n"

	printf "@ifnotdocbook\n"
		printf "@cartouche\n"
		printf "@center @b{%s}\n\n", Sidebar_title
			print "@noindent"
			sub(/^\n*/, "", Sidebar_body)	# remove initial newlines
			print Sidebar_body
		printf "@end cartouche\n"
	printf "@end ifnotdocbook\n"
	Sidebar_body = ""
	next
}

Pass == 2 && Collecting_sidebar {
	Sidebar_body = Sidebar_body "\n" $0
	next
}
@

@sidebar Test Sidebar
This is a test sidebar, just to show what one looks like,
and to make sure that the @command{jrweave} code works.

And here is a second paragraph, to show that (in Texinfo) the first
paragraph of a sidebar is not indented, whereas subsequent ones are.
@end sidebar

@node jrweave @TeX{} control
@subsection Additional Features for @TeX{}

There are some additional changes that make the output from @TeX{}
a little bit nicer.  We'll explain them as we go along.

@quotation CAUTION
All of the features in the @value{SUBSECTION} depend upon the
macros in @file{texinfo.tex}.  If they change in an imcompatible way,
these features may break or become impossible to continue to maintain.
Use them with care!
@end quotation

@<Texinfo authoring additions@>=
@<Change cross-reference quoting@>
@<Change PDF internal link color@>
@<Set URL formatting@>
@

I happen to dislike the way chapter and section titles are quoted in
cross-references in @TeX{} output.  You can change to use double-quoted
titles with the @samp{@@dquotexrefs} command:

@<Change cross-reference quoting@> =
Pass == 2 && /^@dquotexrefs[[:space:]]*$/ {
	print "@tex"
#	print "%\\gdef\\xrefprintnodename#1{{\\it #1}}"
	print "\\gdef\\xrefprintnodename#1{``#1''}"
	print "@end tex"

	next
}
@

@noindent
The commented-out @code{print} statement shows an alternative that I
experimented with, to italicize titles, but then the formatting doesn't
look quite as good.

Texinfo is slightly schizophrenic in relation to output from @TeX{}.
In particular, PDF provides the ability to have @dfn{links}, both
within the document and to external URLs.  In a PDF viewer, clicking
on an internal link takes you to the target, whereas clicking on a URL
starts a web browser.  Previously, when a Texinfo file was processed with
pdf@TeX{}, both cross-references and URLs were formatted as PDF links,
in a different color.

On the other hand, regular DVI output is aimed more for printing.  Thus,
when run with regular @TeX{}, Texinfo documents showed URLs inline in
the text, and cross references were printed in black.

It is important to note that PDF files can also be used as the master
for printing.  In such a case, you @emph{don't} want cross-references
in a different color and you do want URLs to appear in the text.

Because of this, in November 2013, @file{texinfo.tex} was changed to use
the DVI printing style for both cross-references and URLs. However,
facilities were documented for enabling the previous behavior should
you wish to do so.

The following set of new commands makes it easy to enable these
features if you wish.  Use:

@example
@@pdflinkcolor @r{[} @var{red green blue} @r{]}
@end example

This sets the color for internal links.  Here, @var{red}, @var{green}
and @var{blue} are values between zero and one (inclusive) to indicate
how much of each color to use in creating the final color.
The default is the previous value used by @file{texinfo.tex},
called ``dark red'': 0.50 red, 0.09 green, and 0.12 blue.

@(jrweave@) =
BEGIN {
	Dark_red = "0.5 0.09 0.12"
}
@

@<Change PDF internal link color@> =
Pass == 2 && /^@pdflinkcolor[[:space:]]*.*$/ {
	if (NF != 1 && NF != 4)
		fatal(_"@pdflinkcolor: either no arguments or three arguments required")

	if (NF == 1)
		Link_color = Dark_red
	else {
		$1 = ""
		$0 = $0
		Link_color = $0
	}

	print "@tex"
	print "\\gdef\\linkcolor{" Link_color "}"
	print "@end tex"

	next
}
@

Similar to internal links, you can set the color of URL links.
They are independant of each other. The command here is @samp{@@urllinkcolor}:

@<Set URL formatting@> =
Pass == 2 && /^@urllinkcolor[[:space:]]*.*$/ {
	if (NF != 1 && NF != 4)
		fatal(_"@urllinkcolor: either no arguments or three arguments required")

	if (NF == 1)
		URL_color = Dark_red
	else {
		$1 = ""
		$0 = $0
		URL_color = $0
	}

	print "@tex"
	print "\\gdef\\urlcolor{" URL_color "}"
	print "@end tex"

	next
}
@

Besides setting the color for URLs, you can control whether the text of
a URL should appear in the document text, or not. By default, it does
appear.  To make it disappear, use @samp{@@hideurls}:

@<Set URL formatting@> =
Pass == 2 && /^@hideurls[[:space:]]*$/ {
	print "@tex"
	print "\\global\\urefurlonlylinktrue"	# NOTE: *not* \gdef
	print "@end tex"

	next
}
@

@c ============== start here to rework def/use tracking and printing.

@node jrweave def/use tracking
@section Tracking Definitions and Uses

@quotation
Stuff from Mike Brennan here
@author Michael Brennan
@end quotation

As mentioned at the beginning of this @value{CHAPTER}, at the place
where a chunk is defined (or added on to) we want to
be able to present to the reader a list of where the chunk is used,
where else it is defined, and the definition points for any other chunks
it references.

We start by collecting this information and tracking it.
We collect the information during the first pass.

@c ============== end here to rework def/use tracking and printing.

@node jrweave chunk indexes
@section Creating Indices For Chunks

Besides printing out the list of file definitions and code chunk
definitions and references (@pxref{jrweave file defs}, and
@pxref{jrweave code defs and refs}), @command{jrweave} creates index entries for
each chunk's definition(s) and use(s).  This provides an easy way to
find information based on alphabetic lookup of a chunk name.

The index names are @samp{cd} for ``chunk definition'' and
@samp{cr} for ``chunk reference.''
It is up to the author of a document to either print the indices
using a regular Texinfo @code{@@printindex} command or to merge
them into one of the standard Texinfo indices.  I have taken
the latter course. Towards the front of this @value{DOCUMENT} I have

@example
@@synindex cd cp
@@synindex cr cp
@end example

@(jrweave@) =
@<Create Chunk Indices@>
@

According to the Texinfo manual, new indices should be created right
after the Texinfo header.

@<Create Chunk Indices@> =
Pass == 2 && /^@c %\*\*end of header/ {
	print	# print the line

	print "\n@c Extra indices added by jrweave"
	print "@defindex cd   @c chunk definition"
	print "@defindex cr   @c chunk reference"

	next
}
@

@node jrweave file chunks
@section Processing File Chunks for @command{jrweave}

Now comes the hard part. We use the same process for file chunks
and for code chunks, although each will be tracked separately.

@(jrweave@) =
@<Process file chunks for @code{jrweave}@>
@<Process code chunk for @command{jrweave}@>
@

The initial code is similar to that of @command{jrtangle}.

@<Process file chunks for @code{jrweave}@>=
$0 ~ File_chunk_pattern {
	@<Common file chunk initial processing@>
	@<Collect chunk information@>
	next
}
@

We need the following information: The file's name, and a running
count of how many times this file has been seen.  This running count
is used to create an @code{@@anchor@{@}} for this definition.
We also have a global running count of files.
In addition, we need to save the file's name and
the current anchor value for when we build the list of where
each code chunk is referenced; this list can then be printed
later with the @code{@@print_code_refs} command
(@pxref{jrweave print code refs}).

Because file chunk and code chunk collection and expansion
are so similar, they will share data structures, so that
the expansion code needs to be written only once.

@<Collect chunk information@>=
# Create array for this chunk
Chunk_info[Current_chunk][0]++
if (Pass == 1) {
	@<Store info for chunk@>
} else
	Chunk_info[Current_chunk]["defn"]++
@

@<Store info for chunk@>=
if (! ("chunk number" in Chunk_info[Current_chunk])) {
	Chunk_info[Current_chunk]["chunk number"] = \
							++Chunk_numbers[Chunk_type]
}
@

@<Process file chunks for @code{jrweave}@>=
@<Handle terminating at-sign for file and code chunks@>
@<Collect chunk lines@>
@

Here is where we format the file chunks.

@findex @code{end_file_gathering()} function, @command{jrweave}
@<Process file chunks for @code{jrweave}@>=
function end_file_gathering(	x, y, n, i, parts, names,
								name, anchor, chunk_being_used)
{
	if (Pass == 1) {
		Chunk_lines = ""
		Flags["file chunk"] = FALSE
		return
	}

	# On the second pass, format the chunk
	@<Print the chunk body@>
}
@

Printing the chunk encompasses printing the leading stuff,
formatting the code lines for @TeX{}, such as expanding tabs,
formatting the names of the referenced chunks, and
closing off the environment.

@<Print the chunk body@> =
@<Try to keep at least the first two lines of the chunk together@>
@<Print the anchor@>
@<Convert the lines for @TeX{}@>
@<Format chunk names and reassemble output lines@>
@<Print the complete chunk@>
@

For aesthetic purposes, it would be good to keep at least the first
two lines of the chunk together.  The Texinfo command to do this
is @code{@@need}, which takes an argument in ``mils''---thousandths of
an inch.

So, how many thousandths of an inch do two lines take? Karl Berry advised
to try using @samp{@@showthe@@baselineskip}.  The result is 13.2 points.
There are 72 points in an inch, so one line is 13.2 divided by 72 = 0.183
inches.  Multiply that by two, and we get 0.367 inches.  We round that
up to a slightly larger number in the hopes that this will actually work:

@<Try to keep at least the first two lines of the chunk together@> =
print "@need 400"
@

Formatting the anchor is handled by a separate function which
we'll see later. The output is the anchor, the formatted chunk
name and the opening @code{@@example} or @code{@@smallexample}.

@page
@<Print the anchor@> =
anchor = format_anchor(Current_chunk, Chunk_info[Current_chunk]["defn"])
printf("%s\n", anchor)
@

Converting the lines means expanding the tabs, and then splitting the
total set of lines apart at each chunk name.  The regular text goes
into the array @code{parts}, and the chunk names into the array @code{names}.

@<Convert the lines for @TeX{}@> =
x = expand_tabs(Chunk_lines, Tabstop)
# extract code chunks
n = split(x, parts, Chunk_name_pattern, names)

# escape special chars in parts of code that aren't chunk names
for (i = 1; i in parts; i++)
	gsub(/[@{}]/, "@&", parts[i])
@

@<Format chunk names and reassemble output lines@> =
y = parts[1]
if (n > 1) {	# embedded chunk names
	for (i = 1; i in names; i++) {
		name = strip_out_name(names[i])
		@<Collect chunk reference information@>
		chunk_being_used = \
			format_chunk_name(name, Chunk_info[name]["chunk number"], "code chunk")
		printf("@crindex %s, use\n", chunk_being_used)
		y = y chunk_being_used
		y = y parts[i+1]
	}
}
@

@<Print the complete chunk@> =
chunk_being_defined = \
	format_chunk_name(Current_chunk, Chunk_info[Current_chunk]["chunk number"],
						Chunk_type)
printf("@cdindex %s, definition\n", chunk_being_defined)
printf("@noindent\n%s %s@equiv{}\n",
	chunk_being_defined, Chunk_info[Current_chunk]["defn"] == 1 ? "" : "+")
print Example_start
printf("%s\n", y)
print Example_end
@

@node jrweave code chunks
@section Processing Code Chunks for @command{jrweave}

Code chunk collection and formatting can now benefit from all
the work done previously.

@<Process code chunk for @command{jrweave}@> =
$0 ~ Code_chunk_pattern {
	@<Common code chunk initial processing@>
	@<Collect chunk information@>
	next
}
@

For weaving, we collect the code lines and then when
done, print out the chunk nicely formatted.

@findex @code{end_code_gathering()} function, @command{jrweave}
@<Process code chunk for @command{jrweave}@> =
function end_code_gathering(	i, j, n, x, parts, names, name, anchor)
{
	if (Pass == 1) {
		Chunk_lines = ""
		Flags["code chunk"] = FALSE
		return
	}

	# In second pass, print the code
	@<Print the chunk body@>

	if (Debug ~ /code/)
		printf("finished formatting code %s\n", Code_chunk) > "/dev/stderr"
}
@

@node jrweave print setup recipe
@section Printing The Initial Setup Recipe

It may be that an author wants to include the initial setup
in the printed document.  To do so, place
@samp{@@print_initial_setup @r{[}@var{chunkname}@r{]}}
into the @value{TWJR} document on a line by itself.
If no @var{chunkname} is provided, then the chunk is
named ``Initial setup.''

@(jrweave@) =
@<Handle the initial setup chunk for @code{jrweave}@>
@

@cindex @code{@@print_initial_setup} command, @command{jrweave}
@cindex @code{@@initial_setup} command, @command{jrweave}
@<Handle the initial setup chunk for @code{jrweave}@> =
/^@print_initial_setup([[:space:]]+.*|[[:space:]]*)$/ {
	Print_initial_setup = TRUE
	if (NF > 1) {
		$1 = ""
		$0 = $0
		Initial_setup_name = $0
	}
	else
		Initial_setup_name = "Initial setup"

	next
}

/^@initial_setup[[:space:]]*$/, /^@end initial_setup[[:space:]]*$/ {
	if (Pass == 1 || ! Print_initial_setup)
		next

	Chunk_info[Initial_setup_name]["type"] = "code chunk"
	Chunk_info[Initial_setup_name]["defn"] = 1
	if (/^@initial_setup[[:space:]]*$/) {
		printf("%s\n", format_anchor(Initial_setup_name, 1))
		printf("@noindent\n%s @equiv{}\n",
			format_chunk_name(Initial_setup_name, 0, "code chunk"))
		print Example_start
	} else if (/^@end initial_setup[[:space:]]*$/) {
		print Example_end
	} else {
		x = expand_tabs($0, Tabstop)
		gsub(/[@{}]/, "@&", x)
		print x
	}

	next
}
@

@node jrweave file defs
@section Printing File Definitions 

At this point we have collected and printed all the file and code
defintion chunks. Along the way we have gathered information about where
each chunk is defined and where each chunk is referenced (used inside
a chunk body).

We are now able to print the lists of everywhere that file chunks are
defined.

@quotation NOTE
This @emph{must} be done after all file and code chunks have
been printed, since the necessary information is collected during
the second pass.  With some work, this could be fixed by collecting
the information during the first pass, but the general intent is that
these lists be placed in an appendix at the end of the document.
@end quotation

The command to print the file definitions is @code{@@print_file_defs}.
With some luck and some careful programming, we can reuse the code
we'll write here for the code definitions as well.

@(jrweave@) =
@<Handle @code{@@print_file_defs}@>
@

This is done in the second pass:

@cindex @code{@@print_file_defs} command, @command{jrweave}
@<Handle @code{@@print_file_defs}@> =
Pass == 2 && /^@print_file_defs[[:space:]]*$/ {
	@<Print file chunk definition list@>
	next
}
@

We first build a sorted array of file names,
and then print out the definitions in order.

@<Print file chunk definition list@> =
delete Sorted_file_names
j = 1
for (i in Chunk_info) {
	if (Chunk_info[i]["type"] == "file chunk")
		Sorted_file_names[j++] = i
}
asort(Sorted_file_names)	# Sorted by value
@

Next, we have to loop through the names and print out
the relevant info. We do it in a Texinfo @code{@@table}.

@<Print file chunk definition list@> =
print "@table @asis"
for (i = 1; i in Sorted_file_names; i++) {
	name = Sorted_file_names[i]
	@<Format and print chunk definition list@>
}
print "@end table"
@

@<Format and print chunk definition list@> =
tag = format_chunk_name(name, Chunk_info[name]["chunk number"], Chunk_info[name]["type"])
printf("@item %s\n", tag)
n = Chunk_info[name]["defn"]
if (n == 1)
	printf("This chunk is defined in\n")
else
	printf("Multiple definitions occur in\n")
for (j = 1; j <= n; j++) {
	printf("%s", format_xref(name, j))
	if (j == n-1)
		printf(",\nand\n")
	else if (j < n-1)
		printf(",\n")
}
print ".\n"
@

@node jrweave code defs and refs
@section Printing Code Definitions and References

Unlike files, for code we want to print both
definitions and references.

@menu
* jrweave print code defs::     Printing code definitions.
* jrweave print code refs::     Printing code references.
@end menu

@node jrweave print code defs
@subsection  Printing Code Definitions

Printing code definitions is almost identical to printing
file definitions.

@(jrweave@) =
@<Handle @code{@@print_code_defs}@>
@

This too is done in the second pass:

@cindex @code{@@print_code_defs} command, @command{jrweave}
@<Handle @code{@@print_code_defs}@> =
Pass == 2 && /^@print_code_defs[[:space:]]*$/ {
	@<Print code chunk definition list@>
	next
}
@

We first build a sorted array of code chunk names,
and then print out the definitions in order.

@<Print code chunk definition list@> =
@<Create @code{Sorted_code_names}@>
@

Creating the array of sorted code chunk names is also
done when printing code chunk references, so it lives in
its own chunk.

@<Create @code{Sorted_code_names}@> =
delete Sorted_code_names
j = 1
for (i in Chunk_info) {
	if (Chunk_info[i]["type"] == "code chunk")
		Sorted_code_names[j++] = i
}
asort(Sorted_code_names)	# Sorted by value
@

Next, we have to loop through the names and print out
the relevant info. We do it in a Texinfo @code{@@table}.

@<Print code chunk definition list@> =
print "@table @asis"
for (i = 1; i in Sorted_code_names; i++) {
	name = Sorted_code_names[i]
	@<Format and print chunk definition list@>
}
print "@end table"
@

@node jrweave print code refs
@subsection  Printing Code References

Printing code references is the flip side of printing code definitions.

@(jrweave@) =
@<Handle @code{@@print_code_refs}@>
@

First, recognize the @code{@@print_code_refs} command:

@cindex @code{@@print_code_refs} command, @command{jrweave}
@<Handle @code{@@print_code_refs}@> =
Pass == 2 && /^@print_code_refs[[:space:]]*$/ {
	@<Create @code{Sorted_code_names}@>
	@<Print code chunk references list@>
	next
}
@

We start by pretending that we have the information we need,
and printing it out.

@<Print code chunk references list@> =
print "@table @asis"
for (i = 1; i in Sorted_code_names; i++) {
	name = Sorted_code_names[i]

	n = Chunk_info[name]["numrefs"]
	if (n == 0)		# warning printed elsewhere
		continue

	tag = format_chunk_name(name, Chunk_info[name]["chunk number"],
							Chunk_info[name]["type"])
	printf("@item %s\n", tag)
	print "This chunk is referenced in"
	for (j = 1; j <= n; j++) {
		printf("%s", Chunk_info[name]["refs"][j])	# will be an anchor
		if (j + 1 == n)
			printf(",\nand\n")
		else if (j < n)
			printf(",\n")
	}
	printf(".\n\n")
}
print "@end table"
@

Here is how we collect the information.

@<Collect chunk reference information@> =
xref = format_xref(Current_chunk, Chunk_info[Current_chunk]["defn"])
if (! ("numrefs" in Chunk_info[name])) {
	nrefs = Chunk_info[name]["numrefs"] = 1
	Chunk_info[name]["refs"][nrefs] = xref
} else {
	nrefs = Chunk_info[name]["numrefs"]
	if (Chunk_info[name]["refs"][nrefs] != xref) {
		Chunk_info[name]["refs"][++nrefs] = xref
		Chunk_info[name]["numrefs"] = nrefs
	}
}
@

@node jrweave delete jrtangle code
@section Removing Stuff For @command{jrtangle}

As with any literate programming system, some commands are only for
tangling, and others are only for weaving.  Although the tangle component
only has to pull out source files and expand code, the weaving
component has to also recognize commands for the tangling component,
in order to keep them out of the document formatter's way.

@(jrweave@) =
@<Remove @code{jrtangle} commands for weaving@>
@

There are only three such commands, and all we have to
do is skip over them with @code{next}.

@cindex @code{@@file_update_recipe} command, @command{jrweave}
@cindex @code{@@file_update} command, @command{jrweave}
@cindex @code{@@post_create} command, @command{jrweave}
@<Remove @code{jrtangle} commands for weaving@> =
/^@file_update_recipe[[:space:]]*$/, \
		/^@end file_update_recipe[[:space:]]*$/ {
	next
}
/^@file_update[[:space:]]/ {
	next
}
/^@post_create[[:space:]]+/ {
	next
}
@

@node jrweave last bit
@section Passing Everything Else Through

Any line in the input document that doesn't match
one of the commands described in the previous section
should be left alone.

@(jrweave@) =
@<Default @code{print} statement for @command{jrweave}@>
@

Thus, the final thing to do is to pass all other lines on through
to the output.  This statement @emph{must} be the last
active rule in @command{jrweave}.

@<Default @code{print} statement for @command{jrweave}@> =
Pass == 2 { print }
@

@node jrweave expanding tabs
@section Expanding Tabs

@TeX{} treats tabs like single spaces.  However, people writing code
like to use tabs to handle indentation.  There are two ways to manage
having real tabs: either set your editor to expand tabs to spaces upon
input, or use real tabs, and expand them when creating the document with
@command{jrweave}.  Since I happen to like using tabs,@footnote{A habit of
over 30 years that is just too hard to break.} I have chosen the latter.

In addition, having literal tabs in a file can be critical: this is most
applicable to @file{Makefile} files but perhaps matters for other kinds
of files as well.


@(jrweave@) =
@<Expand tabs for @command{jrweave}@>
@

Although POSIX-style systems usually expand tabs to every eight columns,
that's a bit much for printed documents like what Texinfo produces.
So, I have chosen to set tabs at every four columns. This choice can be
adjusted using the @option{-v} option to @command{gawk}.

@<Expand tabs for @command{jrweave}@> =
BEGIN {
	if (Tabstop == 0)
		Tabstop = 4		# default tab stops
}
@

I recommend using whatever appropriate magic in the @value{TWJR}
document that will set the tab stop to whatever you prefer
in your favorite editor.  For @uref{http://www.vim.org, Vim},
I use this line, which also switches on syntax highlighting
appropriate to Texinfo. It must be placed within the first four
or so lines of the file.

@example
@@c vim: filetype=texinfo tabstop=4
@end example

The code that expands tabs is fairly straightforward. It first makes
sure that the chosen tab stop is at least two or more.  Next it splits
the string into an input array, @code{chars}, and starts copying the
input to the output (@code{out}) one character at a time. The cases
are as follows:

@table @asis
@item A newline
Upon encountering a newline, we must reset our idea of the output
column back to zero. This is the variable @code{k}.

@item A non-tab
Copy the character to the output and increase @code{k} by one.

@item A tab
Replace the tab with a space and then add spaces until the
output column has reached the next tab stop.

The algorithm is borrowed from the original Berkeley Unix
@command{expand} program, written in C, where arrays are zero-based,
and the check can be made using the bitwise AND operator to see
if more characters remain.
@end table

At the end, we call @code{join()} to convert the @code{out}
array into a single string which can be returned.

@findex @code{expand_tabs()} function, @command{jrweave}
@<Expand tabs for @command{jrweave}@> =
# expand_tabs --- expand tabs in the string

function expand_tabs(string, tabstop,	chars, out, i, j, k, n)
{
	if (tabstop < 2)
		fatal(_"expand_tabs: tabstop %d < 2\n", tabstop)

	n = split(string, chars, "")
	j = k = 0
	for (i = 1; i <= n;) {
		if (chars[i] == "\n") {
			out[j++] = chars[i++]
			k = 0
			continue
		}

		if (chars[i] != "\t") {
			out[j++] = chars[i++]
			k++
			continue
		}
		i++	# skip the tab

		do {
			out[j++] = " "
			k++
		} while (and(k, tabstop-1) != 0)
	}

	return join(out, 0, j, SUBSEP)
}
@

(I suppose this could have been broken out into small chunks
with preceding explanatory text; I'm not sure it would have
made a noticeable difference since this is not a big function.)

@node jrweave helper functions
@section Helper Functions For @command{jrweave}

We finish up with the helper functions needed
by @command{jrweave}.

@(jrweave@) =
@<Helper functions for @command{jrweave}@>
@

The first is a simple function to remove non-alphanumeric
characters from chunk names:

@findex @code{sanitize_name()} function, @command{jrweave}
@<Helper functions for @command{jrweave}@> =
function sanitize_name(file_name)
{
	gsub(/[^[:alnum:]]/, "-", file_name)

	return file_name
}
@

Next are functions to do various kinds of formatting.
Since formatting anchors and references are similar,
a helper function does the work, with the main functions
delegating to it:

@findex @code{format_anchor_or_ref()} function, @command{jrweave}
@findex @code{format_anchor()} function, @command{jrweave}
@findex @code{format_xref()} function, @command{jrweave}
@<Helper functions for @command{jrweave}@> =
function format_anchor_or_ref(type, name, defn,		clean_name, result)
{
	clean_name = sanitize_name(name)
	if (defn > 0)
		result = sprintf("@%s{%s-%d}", type, clean_name, defn)
	else
		result = sprintf("@%s{%s}", type, clean_name)

	return result
}

function format_xref(name, defn)
{
	return format_anchor_or_ref("ref", name, defn)
}

function format_anchor(name, defn)
{
	return format_anchor_or_ref("anchor", name, defn)
}
@

Finally, the formatting of chunk names varies based on whether
it is file chunk or a code chunk.

@findex @code{format_chunk_name()} function, @command{jrweave}
@<Helper functions for @command{jrweave}@> =
function format_chunk_name(name, count, type,	result, left, right, style)
{
	if (type == "file chunk") {
		left = "@{"
		right = "@}"
		style = "file"
	} else if (type == "code chunk") {
		left = "<"
		right = ">"
		style = "i"
	} else
		fatal(_"format_chunk_name: Unknown chunk type `%s'\n", type)

	if (count > 0)
		result = sprintf("@r{%s@%s{%s} @oldnum{%d}%s}",
						left, style, name, count, right)
	else
		result = sprintf("@r{%s@%s{%s}%s}", left, style, name, right)

	return result
}
@

@node Bootstrapping
@chapter Bootstrapping The System

@quotation
Who will compile the compiler?@footnote{Yes, I made up this quote.}
@author Lady Ada Lovelace
@end quotation

This @value{CHAPTER} discusses the initial bootstrapping process,
presents the initial setup recipe for the @value{TWJR} software,
presents a @file{Makefile} for ongoing maintenance, and describes
how to access the software using @command{git}.

@menu
* Initial bootstrapping::       Bringing up the system from scratch.
* The initial setup::           The initial setup.
* The Makefile::                Keeping the system going.
* Downloading from git::        Downloading from the @command{git} Repository.
@end menu

@node Initial bootstrapping
@section Bringing Up The System From Scratch

Any literate programming system needs to be bootstrapped. As a first step,
the tangle program, if it is compiled, must be given to the compiler as
straight code.  This is true also if it is written in a scripting language.

Once you have a working tangle program, you can generate the final one from
the literate program, and also extract the weave program. Once you have the
weave program, you can generate a document to be formatted with @TeX{},
@LaTeX{}, @command{troff}, a DocBook processor, or whatever.  So that's
the basic idea.

How did I bootstrap things?

Initially, I wrote a minimal version of @command{jrtangle}, called
@command{jrtangle0}.  I wrote this in straight @command{gawk}, but with
many more comments than usual.  This was not so hard: The fact that
@command{awk} lets you put functions anywhere in the file, along with
allowing multiple @code{BEGIN} and @code{END} blocks anywhere in the file,
mitigates some of the need for building up chunks in the way that is
normally done with @command{WEB}-like tools.  When writing the bootstrap
version of @command{jrtangle}, it was straightforward to write in a linear
fashion and just drop in yet another @code{BEGIN} block or function.

The next step was then to take @command{jrtangle0}, integrate it into
@file{texiwebjr.twjr} and start breaking it up into chunks and adding
more prose.  From that point on I could add enhancements as well.
I continued to use @command{jrtangle0} until @command{jrtangle} could
bootstrap itself.  This is established when the following works:

@example
jrtangle0 texiwebjr.twjr    @ii{Create jrtangle}
mv jrtangle jrtangle1       @ii{Rename it}
./jrtangle1 texiwebjr.twjr  @ii{Run it}
cmp jrtangle jrtangle1      @ii{Should produce no output}
@end example

Occasionally, I found a bug or more general case that I had
not handled in @command{jrtangle0}. In such cases, I went
back and fixed the problem there too, so that I could continue
to bootstrap from ground zero.

Once @command{jrtangle} is functional, the next step is to write
@command{jrweave}.  This, of course, can be done from the start
in a literate fashion, since @command{jrtangle} creates it for us.

The initial version of @command{jrweave} was pretty simple. It handled
@samp{@@ifweave @r{@dots{}} @@end ifweave} and
@samp{@@iftangle @r{@dots{}} @@end iftangle}, and the earliest supported
additional commands (@code{@@post_create}). It then simply formatted the
file and code chunks using @code{@@example}, escaping the characters
@samp{@@}, @samp{@{}, and @samp{@}}, and expanding tabs.  This was enough
to produce a straight Texinfo document that could be formatted and viewed
onscreen (say, with a PDF viewer).

From that point on, I could add one feature at a time, and test the
features as I went along.

@node The initial setup
@section The Initial Setup

Mainly to check out the code, we provide an initial setup recipe.
And for fun, we print it:

@initial_setup
if [ ! -d bin ]
then
#	echo making bin
	mkdir bin
# else
#	echo bin is there
fi
@end initial_setup

@print_initial_setup

@node The Makefile
@section Keeping Things Going With @command{make}

Of course, no project would be complete without a @file{Makefile}.
This one does the minimum, which is to bootstrap @command{jrtangle}
and @command{jrweave} and to create a PDF of the @value{DOCUMENT}.

In addition, it can create HTML and DocBook versions, including a PDF
from the DocBook XML file, using @command{dblatex}.  The latter is
considerably uglier than the file produced by @TeX{}, Computer Modern
fonts not withstanding.  It does prove, though, that it is possible
to create valid DocBook from a @value{TWJR} file.

If I ever go the route of making a real distribution, there are many
more common targets that should be added here. For now though, this
suffices.

@(Makefile@) =
@<GPL 3 Copyright statement@>

# FIXME: Maybe make the Makefile depend on the .twjr file.
# FIXME: Run xmllint on the xml file.

SOURCE = texiwebjr.twjr
TEXISOURCE = texiwebjr.texi

all: jrweave jrtangle texiwebjr.pdf

jrweave jrtangle: $(SOURCE)
	./bootstrapping/jrtangle0 $(SOURCE)

$(TEXISOURCE): $(SOURCE) jrweave
	./jrweave $(SOURCE) > $(TEXISOURCE)

texiwebjr.pdf: $(TEXISOURCE)
	texi2dvi --pdf --batch --build-dir=texiwebjr.t2p \
		-o texiwebjr.pdf texiwebjr.texi

docbook: texiwebjr.xml

texiwebjr.xml: $(TEXISOURCE)
	makeinfo --docbook $(TEXISOURCE)

dbpdf: docbook
	dblatex texiwebjr.xml

html: texiwebjr.html

texiwebjr.html: $(TEXISOURCE)
	makeinfo --no-split --html $(TEXISOURCE)
@

@node Downloading from git
@section Downloading From The @command{git} Repository

The code for @value{TWJR} is available from GitHub.
To get it, you will need a @uref{http://git-scm.org, @command{git}}
client of some kind.  The instructions here presume a command-line
style client.

@example
git clone https://github.com/arnoldrobbins/texiwebjr
cd texiwebjr
./bootstrapping/jrtangle0 texiwebjr.twjr
make
@end example

When you're done, you will have @command{jrweave}, @command{jrtangle} and
the @file{Makefile} in your current directory and a @file{texiwebjr.pdf}
PDF file as well.  This file may be printed or viewed on screen with a
PDF viewer.

You will need to have a working @TeX{} installation, and also a version
of @command{texi2pdf} and @command{makeinfo}.  The latter should come from
the Texinfo 5.2 distribution, or newer.

These instructions assume that you have @command{gawk} version 4.0
or later installed in @file{/usr/local/bin}. If not you will have to
use something like @samp{gawk -f ./jrweave @r{@dots{}}} (assuming that
@command{gawk} 4.0 or later is in your search path somewhere).

@cindex @command{gawk} distribution
And of course, if you don't have @command{gawk}, the canonical
incantation is:

@example
wget http://ftp.gnu.org/gnu/gawk/gawk-4.1.0.tar.gz
gzip -d < gawk-4.1.0.tar.gz | tar -xpf -
cd gawk-4.1.0
./configure && make
# magic here to install, often sudo make install
@end example

@node Evaluation and Futures
@chapter Evaluation and Future Work

@cindex Kernighan, Brian W.@:
At this point, we can stop and look at what we've accomplished. Together
@command{jrtangle} and @command{jrweave} comprise around 1,200 lines of
code.  That's a substantial amount of @command{awk}.@footnote{Especially
as Brian Kernighan keeps insisting that two lines is the optimal size
for an @command{awk} program!} Nonetheless, I think that the literate
programming style eased the development and makes understanding the
program pretty easy.  What follows are some semi-random thoughts.

What you see is the final product; it evolved during development.
Unfortunately, there is no good way to present, in a static document
like this one, the dynamics of the software development, and to show
how the program changed as it grew.@footnote{The morbidly curious can
go grovelling through the history in the @command{git} repository.
However, I'm not sure that's a good use of anyone's time.} The best I
can do is make some appropriate notes in the prose in the right places;
e.g., that chunks are stored without the final newline.

Additionally, I don't claim that there is anything earth-shaking or
stunningly innovative here.  What I have done is show that a useful,
usable literate programming system can be created in a few weeks of
spare-time work, with under 1,200 lines of @command{awk}. That's pretty
good.  Of course, ``the proof is in the pudding;'' I won't know how good
a job I've really done until I use @value{TWJR} to write something else,
of medium to large size.

There are a few design decisions that might need revisiting once
I start using @value{TWJR} for ``real work.''

@itemize @bullet
@item
Always producing every file and letting the user supply code to
deal with updating it may be too time consuming. On the other hand,
when compared with actual compilation time for large C and C++ files,
the time in this step may turn out to be neglible.

@item
Right now @command{jrweave} always sends the generated Texinfo file to
standard output. Perhaps instead the output file should be derived from
the name of the input file with the same kind of ``did it change?'' checking
being done by @command{jrweave}, instead of this having to be done in the
@file{Makefile} (if at all).

@item
The generated list of file definitions, and of chunk definitions and references 
aren't wonderful. It might be necessary to track the current @code{@@node}
and maybe chapter / section / subsection to do this really well. On the other
hand, that looks to be a fair amount of work.

@end itemize

I can think of several possible future enhancements:

@itemize @bullet
@item
Some kind of general mechanism for adding in @code{#line}
statements for C and C++.

@item
Similar to @command{noweb}, the ability to include leading prose
in the generated code as a comment.

@item
A way to specify that a chunk should include the leading text on
all expanded lines.  This would be useful, for example, with the
GPL copyright block.  In a @code{Makefile} or shell script I could
perhaps do something like this:

@example
#! /bin/sh
#
# @@<GPL 3 Copyright statement@@>	@@c jrtangle_use_prefix
#
@end example

@noindent
This would precede all the lines of the copyright block with @samp{#}, whereas
in C or C++ code, it would look like this:

@example
/*
 * @@<GPL 3 Copyright statement@@>	@@c jrtangle_use_prefix
 */
@end example

Of course, we can't just do this all the time; it would break something
like

@example
if (@@<some condition@@>) @dots{}
@end example

@noindent
in the case that @code{@@<some condition@@>} was a multiline condition.

@item
One thing that definitely still needs doing is to check
for chunks that were defined but not expanded.

@item
Another thing is to look for case differences and or whitespace
differences (that is, typos) in chunk names. Neither program is
very robust about this right now.
@end itemize

One thing I noted during development: Copy--paste development causes
problems.  The original operations for file chunks and code chunks were
similar but not identical.  This made it hard to get the code right and
eventually led to a large refactoring of the whole business (file + code)
@iftex
@math{\times}
@end iftex
@docbook
&times;&sp;
@end docbook
@ifnottex
@ifnotdocbook
x
@end ifnotdocbook
@end ifnottex
(@command{jrtangle} + @command{jrweave}).
Of course, ultimately, this was a major improvement.

@node Command summary
@appendix Alphabetic List of @value{SHORTTITLE} Commands and Variables

Here is the complete list of commands that @value{TWJR}
adds to the Texinfo markup language.

@table @code
@item @@(@var{filename}@@) =
Start or add to the definition of @var{filename}'s contents.
@xref{jrtangle file chunks}, and @ref{jrweave file chunks}.

@item @@<@var{chunkname}@@> =
Start or add to the definition of a code chunk named @var{chunkname}.
@xref{jrtangle code chunks}, and @ref{jrweave code chunks}.

@item @@dquotexrefs
In @TeX{} output, change cross references to enclose chapter
and section titles in double quotes instead of in square
brackets.

@item @@EMAIL@{@var{real}, @var{spelled}@}
Use @var{spelled} as the email address for HTML output.
Use @var{real} as the email address for anything else.
This is to help avoid having one's email address harvested
by spammers.
@xref{jrweave additional macros}.

@item @@file_update @var{file} @var{directory} @var{suffix}
Set the @var{directory} and @var{suffix} parameters to use for @var{file}'s
file update recipe. @xref{jrtangle avoiding update}.

@item @@file_update_recipe @r{@dots{}} @@end file_update_recipe
Replace the default file update recipe with the enclosed code lines.
This should be system level (``shell'') code.
@xref{jrtangle avoiding update}.

@item @@FIXME@{@var{text}@}
Add a ``FIXME'' note to the text for use during writing.
@xref{jrweave additional macros}.

@item @@hideurls
In @TeX{} output, URLs from @code{@@url} and @code{@@uref}
are formatted as links, instead of being placed into
the body of the text.

@item @@iftangle @r{@dots{}} @@end iftangle
Pass the enclosed lines through when tangling and delete
them when weaving.
@xref{jrtangle ifweave iftangle}, and
@ref{jrweave ifweave iftangle}.

@item @@ifweave @r{@dots{}} @@end ifweave
Pass the enclosed lines through when weaving and delete
them when tangling.
@xref{jrtangle ifweave iftangle}, and
@ref{jrweave ifweave iftangle}.

@item @@initial_setup @r{@dots{}} @@end initial_setup
Define the actions to be done before @command{jrtangle}
creates any files. @xref{jrtangle before everything}.

@item @@oldnum@{@var{number}@}
Set @var{number} in @TeX{}'s @code{\oldstyle} font. This
is for use by @command{jrweave}, and not directly
by the author of a document.

@item @@pdflinkcolor @r{[} @var{red green blue} @r{]}
In @TeX{} output, links within the document (such as
cross references) show up in the color defined by
@var{red}, @var{green}, and @var{blue}.
If not provided, ``dark red'' is used.

@item @@post_create @var{filename} @var{command to run}
Arrange to run @var{command to run} after @var{filename}
has been created. @xref{jrtangle after creation}.

@item @@print_code_defs
Print an alphabetically sorted list of code chunk definitions
at this point in the document.
@xref{jrweave print code defs}.

@item @@print_code_refs
Print an alphabetically sorted list of code chunk references
at this point in the document.
@xref{jrweave print code refs}.

@item @@print_file_defs
Print an alphabetically sorted list of file chunk definitions
at this point in the document.
@xref{jrweave file defs}.

@item @@print_initial_setup
Print the initial setup code at this point in the document.
@xref{jrweave print setup recipe}.

@item @@sidebar @var{title} @r{@dots{}} @@end sidebar
Create a sidebar named @var{title}.
For DocBook output, create a real @code{<sidebar>} element.
For anything else, fake it using Texinfo's @code{@@cartouche}
environment.  @xref{jrweave sidebars}.

@item @@urllinkcolor @r{[} @var{red green blue} @r{]}
In @TeX{} output, URLs from @code{@@url} and @code{@@uref}
formatted as links show up in the color defined by
@var{red}, @var{green}, and @var{blue}.
If not provided, ``dark red'' is used.

@item @@use_example
After occurrences of this command, code is formatted
using @code{@@example}, until a subsequent @code{@@use_smallexample}
command. The initial default is to use @code{@@example}.
@xref{jrweave choosing code size}.

@item @@use_smallexample
After occurrences of this command, code is formatted
using @code{@@smallexample}, until a subsequent @code{@@use_example}
command. The initial default is to use @code{@@example}.
@xref{jrweave choosing code size}.

@end table

The following @command{awk} variables can be set on the
command line with the @option{-v} option to change how
@command{jrtangle} and @command{jrweave} behave:

@table @code
@item Debug
This should be one or more keywords which are searched for regexp match.
If there's a match, an appropriate debugging message is printed.

@item Shell_debug
This can be set to an arbitrary string that is prefixed
to any commands to be run by @code{system()}. If you do so,
it is up to you to get the command syntax right.

@item Tabstop
This controls how many spaces are used to expand real tab characters.
@end table

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::            Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu

@node File Definitions
@appendixsec Source File Definitions

@print_file_defs

@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs

@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs

@node Use of @command{gawk} features
@appendix Features Specific to @command{gawk}

The code for @command{jrtangle} and @command{jrweave} makes free use of
features that are only in @command{gawk}. This @value{APPENDIX} notes them, with
some discussion of what would have to be done to use a POSIX standard
version of @command{awk}.

In practice, @command{gawk} is quite portable, and it's likely that if
you're reading this and are interested in using @value{TWJR} yourself,
then you won't mind building @command{gawk} and having it available.

@table @asis
@item The @code{gensub()} function
The @value{TWJR} code takes advantage of @code{gensub()}'s ability to
pull out the pieces that much subparentheses. This would have to be
done more manually in a standard @command{awk}, using @code{match()}
and @code{substr()}.

@item The four-argument version of @code{split()}
The fourth argument to @code{split()} is an array that holds the text
in between the pieces that matched the pattern.  This too would have
to be done manually using @code{match()} and @code{split()}.

@item Bitwise functions
The @code{and()} function is used in the calculation for expanding
tabs. This would have to be done differently in a standard @command{awk}.

@item Translatable strings
This one is easy. A translatable string looks like the concatenation of
a variable named @samp{_} with a string constant. Such constructs should
work as-is in other @command{awk} versions.
Of course, it would be nice if I were to follow through by setting
@code{TEXTDOMAIN} and setting up the @file{Makefile} to produce the
@file{texiwebjr.pot} file. Let's just move on, shall we?

@item Multidimensional Arrays
Here too, the standard syntax could be made to work, by contorting
the code slightly. However, the multidimensional arrays are cleaner.

@item @code{length(@var{array})}
In at least one place, we use the minor extension that
@code{length(@var{array})} returns the number of elements in the
array.  Both Brian Kernighan's @command{awk} and current versions of
@command{mawk} support this feature. I don't think it has yet made its
way into POSIX, though.
@end table

@node Bibliography
@unnumbered Bibliography

@enumerate

@item
@uref{http://www-cs-faculty.stanford.edu/~knuth/lp.html,
@cite{Literate Programming}},
Donald E.@: Knuth,
Center for the Study of Language and Information, 1992.
ISBN-10: 0937073806,
ISBN-13: 978-0937073803.

@item
@cindex @command{gawk} documentation
@uref{http://www.gnu.org/software/gawk/manual/,
@cite{GAWK: Effective AWK Programming}},
Arnold D. Robbins,
Free Software Foundation, Cambridge, Massachusetts, 2013.
Distributed with the source code for @command{gawk}.

@item
@uref{http://www-cs-faculty.stanford.edu/~knuth/abcde.html,
@cite{Computers & Typesetting}}. This five-volume boxed set of hardback
books contains the documentation and source for both @TeX{} and @MF{},
as well as the Computer Modern fonts.  It is worthwhile to obtain the
``millineum edition'' which includes fixes for all known issues up to
the last time it was printed.  My copy is dated 2011.

@enumerate a
@item
Volume A, @cite{The @TeX{}book},
Donald E.@: Knuth,
Addison-Wesley, Reading, Massachusetts, 1984.
ISBN-10 0-201-13447-0.
ISBN-13: 978-0201134476.

@item
Volume B, @cite{@TeX{}: The Program},
Donald E.@: Knuth,
Addison-Wesley, Reading, Massachusetts, 1986.
ISBN-10: 0-201-13437-3.
ISBN-13: 978-0201134377.

@item
Volume C, @cite{The @MF{}book},
Donald E.@: Knuth,
Addison-Wesley, Reading, Massachusetts, 1986.
ISBN-10: 0-201-13445-4.
ISBN-13: 978-0201134452.

@item
Volume D, @cite{@MF{}: The Program},
Donald E.@: Knuth,
Addison-Wesley, Reading, Massachusetts, 1986.
ISBN-10: 0-201-13438-1.
ISBN-13: 978-0201134384.

@item
Volume E, @cite{Computer Modern Typefaces},
Donald E.@: Knuth,
Addison-Wesley, Reading, Massachusetts, 1986.
ISBN-10: 0-201-13446-2.
ISBN-13: 978-0201134469.
@end enumerate

@item
@uref{http://www.ctan.org,
The Comprehensive @TeX{} Archive Network}.

@end enumerate

@node Concept Index
@unnumbered Index

@printindex cp

@bye

TODO:
- Full indexing of variables and functions
- Write a script to create texiwebjr.pot ?
- Option to print out file update recipe?
- Footnotes inside or outside of punctuation
